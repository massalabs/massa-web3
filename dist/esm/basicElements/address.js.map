{"version":3,"file":"address.js","sourceRoot":"","sources":["../../../src/basicElements/address.ts"],"names":[],"mappings":"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","sourcesContent":["import Base58 from '../crypto/base58'\nimport Serializer from '../crypto/interfaces/serializer'\nimport { Version, Versioner } from '../crypto/interfaces/versioner'\nimport VarintVersioner from '../crypto/varintVersioner'\nimport { PublicKey } from './keys'\nimport varint from 'varint'\n\nconst ADDRESS_USER_PREFIX = 'AU'\nconst ADDRESS_CONTRACT_PREFIX = 'AS'\nconst UNDERLYING_HASH_LEN = 32\n\nconst DEFAULT_VERSION = Version.V0\n\nexport enum AddressType {\n  EOA = 0,\n  Contract = 1,\n}\n\n/**\n * Get the address version.\n *\n * @returns the address version.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction getVersion(data: string | Uint8Array): Version {\n  // when a new version will come, implement the logic to detect version here\n  // This should be done without serializer and versionner as they are potentially not known at this point\n  return Version.V0\n}\n\n/**\n * Get the address prefix.\n *\n *  @remarks\n * Throws an error if the prefix is not valid.\n *\n * @returns the address version.\n */\nfunction getPrefix(str: string): string {\n  const expected = [ADDRESS_USER_PREFIX, ADDRESS_CONTRACT_PREFIX]\n  for (const prefix of expected) {\n    if (str.startsWith(prefix)) {\n      return prefix\n    }\n  }\n  throw new Error(\n    `invalid address prefix: one of ${expected.join(' or ')} was expected.`\n  )\n}\n\n/**\n * A class representing an address.\n *\n * @remarks\n * For now, an address is intrinsically linked (to be understood as a digest of) to the public key.\n *\n * @privateRemarks\n * Interfaces are used to make the code more modular. To add a new version, you simply need to:\n * - Add a new case in the switch statement with the new algorithms to use.\n * - Change the DEFAULT_VERSION version matching the last version.\n * - Change the getVersion method to detect the version from user input.\n * - check the `fromPublicKey` method to potentially adapt how an address is derived from a public key.\n * - Voila! The code will automatically handle the new version.\n */\nexport class Address {\n  // The address in byte format. Address type and version included.\n  private bytes: Uint8Array\n\n  public isEOA = false\n\n  protected constructor(\n    public serializer: Serializer,\n    public versioner: Versioner,\n    public version: Version\n  ) {}\n\n  /**\n   * Initialize a new address object from a version.\n   *\n   * @param version - The version of the address.\n   *\n   * @returns A new address instance.\n   *\n   * @throws If the version is not supported.\n   */\n  protected static initFromVersion(\n    version: Version = DEFAULT_VERSION\n  ): Address {\n    switch (version) {\n      case Version.V0:\n        return new Address(new Base58(), new VarintVersioner(), version)\n      default:\n        throw new Error(`unsupported version: ${version}`)\n    }\n  }\n\n  /**\n   * Initializes a new address object from a serialized string.\n   *\n   * @param str - The serialized address string.\n   *\n   * @returns A new address instance.\n   *\n   * @throws If the address string is invalid.\n   */\n  public static fromString(str: string): Address {\n    try {\n      const version = getVersion(str)\n      const address = Address.initFromVersion(version)\n      const prefix = getPrefix(str)\n\n      address.isEOA = prefix === ADDRESS_USER_PREFIX\n      const versionedBytes = address.serializer.deserialize(\n        str.slice(prefix.length)\n      )\n      const { version: extractedVersion } =\n        address.versioner.extract(versionedBytes)\n      // safety check\n      if (extractedVersion !== version) {\n        throw new Error(\n          `invalid version: ${version}. ${address.version} was expected.`\n        )\n      }\n\n      address.bytes = Uint8Array.from([\n        ...varint.encode(\n          address.isEOA ? AddressType.EOA : AddressType.Contract\n        ),\n        ...versionedBytes,\n      ])\n      return address\n    } catch (e) {\n      throw new Error(`invalid address string: ${e.message}`)\n    }\n  }\n\n  /**\n   * Get the address type from bytes.\n   *\n   * @returns the address type enum.\n   */\n  private getType(): number {\n    if (!this.bytes) {\n      throw new Error('address bytes is not initialized')\n    }\n    return varint.decode(this.bytes)\n  }\n\n  /**\n   * Initializes a new address object from a public key.\n   *\n   * @param publicKey - The public key to derive the address from.\n   *\n   * @returns A new address object.\n   */\n  public static fromPublicKey(publicKey: PublicKey): Address {\n    if (publicKey.version !== Version.V0) {\n      throw new Error(`unsupported public key version: ${publicKey.version}`)\n    }\n    const address = Address.initFromVersion(Version.V0)\n    const rawBytes = publicKey.hasher.hash(publicKey.toBytes())\n    address.bytes = Uint8Array.from([\n      AddressType.EOA,\n      ...address.versioner.attach(Version.V0, rawBytes),\n    ])\n    address.isEOA = true\n    return address\n  }\n\n  /**\n   * Initializes a new address object from versioned bytes.\n   *\n   * @param bytes - The versioned bytes.\n   *\n   * @returns A new address object.\n   */\n  public static fromBytes(bytes: Uint8Array): Address {\n    const version = getVersion(bytes)\n    const address = Address.initFromVersion(version)\n    address.bytes = bytes\n\n    // safety check\n    const addressType = address.getType()\n    const versionedBytes = bytes.slice(varint.encodingLength(addressType))\n    const { version: extractedVersion } =\n      address.versioner.extract(versionedBytes)\n    if (extractedVersion !== version) {\n      throw new Error(\n        `invalid version: ${version}. ${address.version} was expected.`\n      )\n    }\n\n    address.isEOA = addressType === AddressType.EOA\n    return address\n  }\n\n  /**\n   * Versions the address key bytes.\n   *\n   * @returns The versioned address key bytes.\n   */\n  public toBytes(): Uint8Array {\n    return this.bytes\n  }\n\n  /**\n   * Serializes the address to a string.\n   *\n   * @remarks\n   * A address is serialized as follows:\n   * - The version is serialized as a varint and prepended to the address bytes.\n   * - The result is then sent to the serializer.\n   *\n   * @returns The serialized address string.\n   */\n  toString(): string {\n    // skip address type bytes\n    const versionedBytes = this.bytes.slice(\n      varint.encodingLength(this.getType())\n    )\n    return `${\n      this.isEOA ? ADDRESS_USER_PREFIX : ADDRESS_CONTRACT_PREFIX\n    }${this.serializer.serialize(versionedBytes)}`\n  }\n\n  /**\n   * Get address in binary format from a bytes buffer.\n   *\n   * @returns The address in bytes format.\n   */\n  static extractFromBuffer(\n    data: Uint8Array,\n    offset = 0\n  ): { data: Uint8Array; length: number } {\n    // addr type\n    varint.decode(data, offset)\n    const typeLen = varint.decode.bytes\n    if (typeLen === undefined) {\n      throw new Error('invalid address: type not found.')\n    }\n\n    // version\n    varint.decode(data, offset + typeLen)\n    const versionLen = varint.decode.bytes\n    if (versionLen === undefined) {\n      throw new Error('invalid address: version not found.')\n    }\n\n    const addrLen = typeLen + versionLen + UNDERLYING_HASH_LEN\n\n    const extractedData = data.slice(offset, offset + addrLen)\n    return { data: extractedData, length: addrLen }\n  }\n}\n"]}