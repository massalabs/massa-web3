{"version":3,"file":"dataStore.js","sourceRoot":"","sources":["../../src/dataStore.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,IAAI,EAAE,GAAG,EAAE,EAAE,EAAE,MAAM,iBAAiB,CAAA;AAE/C,MAAM,oBAAoB,GAAG,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAA;AAQhD;;;;;GAKG;AACH,SAAS,QAAQ,CAAC,MAAc;IAC9B,OAAO,IAAI,IAAI,EAAE;SACd,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;SAC1B,aAAa,CAAC,EAAE,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;SAC7B,SAAS,EAAE,CAAA;AAChB,CAAC;AAED;;;;;GAKG;AACH,SAAS,OAAO,CAAC,MAAc;IAC7B,OAAO,IAAI,IAAI,EAAE;SACd,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;SAC1B,aAAa,CAAC,EAAE,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;SAC7B,SAAS,EAAE,CAAA;AAChB,CAAC;AAED;;;;;GAKG;AACH,SAAS,WAAW,CAAC,MAAc;IACjC,OAAO,GAAG,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAA;AACxC,CAAC;AAED;;;;;;;;;;;GAWG;AACH,MAAM,UAAU,iBAAiB,CAC/B,SAA8B;IAE9B,MAAM,SAAS,GAAG,IAAI,GAAG,EAA0B,CAAA;IAEnD,gEAAgE;IAChE,SAAS,CAAC,GAAG,CAAC,oBAAoB,EAAE,GAAG,CAAC,OAAO,CAAC,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAA;IAE1E,SAAS,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,CAAC,EAAE,EAAE;QAChC,SAAS,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC,IAAI,CAAC,CAAA;QAC5C,SAAS,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC,IAAI,CAAC,CAAA;QACxC,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAA;IACzD,CAAC,CAAC,CAAA;IAEF,OAAO,SAAS,CAAA;AAClB,CAAC","sourcesContent":["import { Args, U64, U8 } from './basicElements'\n\nconst CONTRACTS_NUMBER_KEY = new Uint8Array([0])\n\ntype DatastoreContract = {\n  data: Uint8Array\n  args: Uint8Array\n  coins: bigint\n}\n\n/**\n * Generates a key for coin data in the datastore.\n *\n * @param offset - The offset to use when generating the key.\n * @returns A Uint8Array representing the key.\n */\nfunction coinsKey(offset: number): Uint8Array {\n  return new Args()\n    .addU64(BigInt(offset + 1))\n    .addUint8Array(U8.toBytes(1n))\n    .serialize()\n}\n\n/**\n * Generates a key for args data in the datastore.\n *\n * @param offset - The offset to use when generating the key.\n * @returns A Uint8Array representing the key.\n */\nfunction argsKey(offset: number): Uint8Array {\n  return new Args()\n    .addU64(BigInt(offset + 1))\n    .addUint8Array(U8.toBytes(0n))\n    .serialize()\n}\n\n/**\n * Generates a key for contract data in the datastore.\n *\n * @param offset - The offset to use when generating the key.\n * @returns A Uint8Array representing the key.\n */\nfunction contractKey(offset: number): Uint8Array {\n  return U64.toBytes(BigInt(offset + 1))\n}\n\n/**\n * Populates the datastore with the contracts.\n *\n * @remarks\n * This function is to be used in conjunction with the deployer smart contract.\n * The deployer smart contract expects to have an execution datastore in a specific state.\n * This function populates the datastore according to that expectation.\n *\n * @param contracts - The contracts to populate the datastore with.\n *\n * @returns The populated datastore.\n */\nexport function populateDatastore(\n  contracts: DatastoreContract[]\n): Map<Uint8Array, Uint8Array> {\n  const datastore = new Map<Uint8Array, Uint8Array>()\n\n  // set the number of contracts in the first key of the datastore\n  datastore.set(CONTRACTS_NUMBER_KEY, U64.toBytes(BigInt(contracts.length)))\n\n  contracts.forEach((contract, i) => {\n    datastore.set(contractKey(i), contract.data)\n    datastore.set(argsKey(i), contract.args)\n    datastore.set(coinsKey(i), U64.toBytes(contract.coins))\n  })\n\n  return datastore\n}\n"]}