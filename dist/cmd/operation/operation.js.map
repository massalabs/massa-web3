{"version":3,"file":"operation.js","sourceRoot":"","sources":["../../../src/operation/operation.ts"],"names":[],"mappings":"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","sourcesContent":["import { Args, ArrayTypes } from '../basicElements'\nimport { SCEvent } from '../client'\nimport { Provider } from '../provider'\nimport { rawEventDecode } from '../utils'\nimport { OperationStatus } from './types'\n\nconst DEFAULT_WAIT_TIMEOUT_MS = 60000\nconst DEFAULT_WAIT_PERIOD_MS = 500\n\n/**\n * An operation object.\n */\nexport class Operation {\n  constructor(\n    public provider: Provider,\n    public id: string\n  ) {}\n\n  /**\n   * Gets the status of the operation.\n   *\n   * @returns The status of the operation.\n   */\n  async getStatus(): Promise<OperationStatus> {\n    return this.provider.getOperationStatus(this.id)\n  }\n\n  /**\n   * Waits for the operation to reach a specific status.\n   *\n   * @param exitThreshold - The minimal status to wait for.\n   * @param timeout - The maximum time to wait.\n   * @param period - The time interval to check the status.\n   *\n   * @returns The status of the operation or NotFound if the timeout is reached.\n   */\n  private wait(\n    exitThreshold: OperationStatus,\n    timeout = DEFAULT_WAIT_TIMEOUT_MS,\n    period = DEFAULT_WAIT_PERIOD_MS\n  ): Promise<OperationStatus> {\n    return new Promise<OperationStatus>((resolve) => {\n      // eslint-disable-next-line @typescript-eslint/no-magic-numbers\n      let elapsedTime = 0\n      const checkStatusInterval = setInterval(async () => {\n        const currentStatus = await this.getStatus()\n        if (currentStatus >= exitThreshold) {\n          clearInterval(checkStatusInterval)\n          resolve(currentStatus)\n        } else if (elapsedTime >= timeout) {\n          clearInterval(checkStatusInterval)\n          resolve(OperationStatus.NotFound)\n        }\n        elapsedTime += period\n      }, period)\n    })\n  }\n\n  /**\n   * Waits for the operation to be included in a block.\n   *\n   * @param timeout - The maximum time to wait.\n   * @param period - The time interval to check the status.\n   *\n   * @returns The status of the operation or NotFound if the timeout is reached.\n   */\n  async waitSpeculativeExecution(\n    timeout?: number,\n    period?: number\n  ): Promise<OperationStatus> {\n    return this.wait(OperationStatus.SpeculativeSuccess, timeout, period)\n  }\n\n  /**\n   * Waits for the block containing the operation to be final.\n   *\n   * @param timeout - The maximum time to wait.\n   * @param period - The time interval to check the status.\n   *\n   * @returns The status of the operation or NotFound if the timeout is reached.\n   */\n  async waitFinalExecution(\n    timeout?: number,\n    period?: number\n  ): Promise<OperationStatus> {\n    return this.wait(OperationStatus.Success, timeout, period)\n  }\n\n  /**\n   * Gets the events of the operation once the block reaches the final state.\n   *\n   * @returns The events of the operation.\n   */\n  async getFinalEvents(): Promise<SCEvent[]> {\n    if ((await this.waitFinalExecution()) === OperationStatus.NotFound) {\n      return Promise.reject(new Error('Operation not found'))\n    }\n\n    return this.provider.getEvents({ operationId: this.id, isFinal: true })\n  }\n\n  /**\n   * Gets the events of the speculative execution of the operation.\n   *\n   * @returns The speculative events of the operation.\n   */\n  async getSpeculativeEvents(): Promise<SCEvent[]> {\n    if ((await this.waitSpeculativeExecution()) === OperationStatus.NotFound) {\n      return Promise.reject(new Error('Operation not found'))\n    }\n\n    return this.provider.getEvents({ operationId: this.id, isFinal: false })\n  }\n\n  async getDeployedAddress(waitFinal = false): Promise<string> {\n    const events = waitFinal\n      ? await this.getFinalEvents()\n      : await this.getSpeculativeEvents()\n\n    const lastEvent = events.at(-1)\n\n    if (!lastEvent) {\n      throw new Error('no event received.')\n    }\n\n    if (lastEvent.context.is_error) {\n      const parsedData = JSON.parse(lastEvent.data)\n      throw new Error(parsedData.massa_execution_error)\n    }\n\n    const contracts = new Args(\n      rawEventDecode(lastEvent.data)\n    ).nextArray<string>(ArrayTypes.STRING)\n    return contracts[0]\n  }\n}\n"]}