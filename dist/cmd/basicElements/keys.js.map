{"version":3,"file":"keys.js","sourceRoot":"","sources":["../../../src/basicElements/keys.ts"],"names":[],"mappings":"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","sourcesContent":["import { Signature } from './signature'\nimport { Address } from './address'\nimport Base58 from '../crypto/base58'\nimport Blake3 from '../crypto/blake3'\nimport Ed25519 from '../crypto/ed25519'\nimport Hasher from '../crypto/interfaces/hasher'\nimport Serializer from '../crypto/interfaces/serializer'\nimport Signer from '../crypto/interfaces/signer'\nimport { Version, Versioner } from '../crypto/interfaces/versioner'\nimport VarintVersioner from '../crypto/varintVersioner'\n\nconst PRIVATE_KEY_PREFIX = 'S'\nconst PUBLIC_KEY_PREFIX = 'P'\n\n/**\n * Get the version from string or bytes key.\n *\n * @remarks\n * For now the function is common for private & public key but it might change in the future.\n *\n * @returns the key version.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction getVersion(data: string | Uint8Array): Version {\n  // When a new version will come, implement the logic to detect version here\n  // This should be done without serializer and versionner as they are potentially not known at this point\n  return Version.V0\n}\n\n/**\n * A class representing a private key.\n *\n * @remarks\n * The private key is used to sign operations during interactions with the blockchain.\n *\n * @privateRemarks\n * Interfaces are used to make the code more modular. To add a new version, you simply need to\n * extend the `initFromVersion` method:\n * - Add a new case in the switch statement with the new algorithms to use.\n * - Add a new default version matching the last version.\n * - Voila! The code will automatically handle the new version.\n */\nexport class PrivateKey {\n  // The key in byte format. Version included.\n  private bytes: Uint8Array\n  private prefix = PRIVATE_KEY_PREFIX\n\n  // eslint-disable-next-line max-params\n  protected constructor(\n    public hasher: Hasher,\n    public signer: Signer,\n    public serializer: Serializer,\n    public versioner: Versioner,\n    public version: Version\n  ) {}\n\n  /**\n   * Initializes a new private key object from a version.\n   *\n   * @param version - The version of the private key. If not defined, the last version will be used.\n   *\n   * @returns A new private key instance.\n   */\n  protected static initFromVersion(version: Version = Version.V0): PrivateKey {\n    switch (version) {\n      case Version.V0:\n        return new PrivateKey(\n          new Blake3(),\n          new Ed25519(),\n          new Base58(),\n          new VarintVersioner(),\n          version\n        )\n      default:\n        throw new Error(`unsupported version: ${version}`)\n    }\n  }\n\n  private checkPrefix(str: string): void {\n    if (!str.startsWith(this.prefix)) {\n      throw new Error(\n        `invalid private key prefix: ${this.prefix} was expected.`\n      )\n    }\n  }\n\n  /**\n   * Initializes a new private key object from a serialized string.\n   *\n   * @param str - The serialized private key string.\n   *\n   * @returns A new private key instance.\n   *\n   * @throws If the private key prefix is invalid.\n   */\n  public static fromString(str: string): PrivateKey {\n    try {\n      const version = getVersion(str)\n      const privateKey = PrivateKey.initFromVersion(version)\n      privateKey.checkPrefix(str)\n      privateKey.bytes = privateKey.serializer.deserialize(\n        str.slice(privateKey.prefix.length)\n      )\n      return privateKey\n    } catch (e) {\n      throw new Error(`invalid private key string: ${e.message}`)\n    }\n  }\n\n  /**\n   * Initializes a new private key object from a byte array.\n   *\n   * @param bytes - The private key in byte format.\n   *\n   * @returns A new private key instance.\n   */\n  public static fromBytes(bytes: Uint8Array): PrivateKey {\n    const version = getVersion(bytes)\n    const privateKey = PrivateKey.initFromVersion(version)\n    privateKey.bytes = bytes\n    return privateKey\n  }\n\n  /**\n   * Initializes a new private key object from the environment variables.\n   *\n   * @param key - The environment variable name containing the private key.\n   *\n   * @remarks\n   * The `PRIVATE_KEY` or the provided key is required in the environment variables.\n   *\n   * @returns A new private key instance.\n   */\n  public static fromEnv(key = 'PRIVATE_KEY'): PrivateKey {\n    const privateKey = process.env[key]\n\n    if (!privateKey) {\n      throw new Error(`missing \\`${key}\\` environment variable`)\n    }\n\n    return PrivateKey.fromString(privateKey)\n  }\n\n  /**\n   * Initializes a random private key.\n   *\n   * @param version - The version of the private key. If not defined, the last version will be used.\n   *\n   * @returns A new private key instance.\n   */\n  public static generate(version?: Version): PrivateKey {\n    const privateKey = PrivateKey.initFromVersion(version)\n    const rawBytes = privateKey.signer.generatePrivateKey()\n    privateKey.bytes = privateKey.versioner.attach(privateKey.version, rawBytes)\n    return privateKey\n  }\n\n  /**\n   * Returns the public key matching to the current private key.\n   *\n   * @returns A new public key instance.\n   */\n  public async getPublicKey(): Promise<PublicKey> {\n    return PublicKey.fromPrivateKey(this)\n  }\n\n  /**\n   * Signs the message with the private key.\n   *\n   * @remarks\n   * This function signs a byte-encoded message. The message is first hashed and then signed.\n   * Do not pass a digest to this function as it will be hashed twice.\n   *\n   * @param message - The byte array to sign.\n   *\n   * @returns The signature byte array.\n   */\n  public async sign(message: Uint8Array): Promise<Signature> {\n    const { data } = this.versioner.extract(this.bytes)\n    const signature = await this.signer.sign(data, this.hasher.hash(message))\n    return Signature.fromBytes(this.versioner.attach(this.version, signature))\n  }\n\n  /**\n   * Private key in bytes.\n   *\n   * @returns The versioned private key bytes.\n   */\n  public toBytes(): Uint8Array {\n    return this.bytes\n  }\n\n  /**\n   * Serializes the private key to a string.\n   *\n   * @remarks\n   * A private key is serialized as follows:\n   * - The version is serialized as a varint and prepended to the private key bytes.\n   * - The result is then sent to the serializer.\n   *\n   * @returns The serialized private key string.\n   */\n  public toString(): string {\n    return `${this.prefix}${this.serializer.serialize(this.bytes)}`\n  }\n}\n\n/**\n * A class representing a public key.\n *\n * @remarks\n * The public key is an essential component of asymmetric cryptography. It is intrinsically linked to the private key.\n *\n * @privateRemarks\n * Interfaces are used to make the code more modular. To add a new version, you simply need to:\n * - extend the `initFromVersion` method:\n *   - Add a new case in the switch statement with the new algorithms to use.\n *   - Add a new default version matching the last version.\n * - check the `fromPrivateKey` method to potentially adapt how a public key is derived from a private key.\n * - Voila! The code will automatically handle the new version.\n */\nexport class PublicKey {\n  // The key in byte format. Version included.\n  private bytes: Uint8Array\n  private prefix = PUBLIC_KEY_PREFIX\n\n  // eslint-disable-next-line max-params\n  protected constructor(\n    public hasher: Hasher,\n    public signer: Signer,\n    public serializer: Serializer,\n    public versioner: Versioner,\n    public version: Version\n  ) {}\n\n  /**\n   * Initializes a new public key object from a version.\n   *\n   * @param version - The version of the private key. If not defined, the last version will be used.\n   *\n   * @returns A new public key instance.\n   *\n   * @throws If the version is not supported.\n   */\n  protected static initFromVersion(version: Version = Version.V0): PublicKey {\n    switch (version) {\n      case Version.V0:\n        return new PublicKey(\n          new Blake3(),\n          new Ed25519(),\n          new Base58(),\n          new VarintVersioner(),\n          version\n        )\n      default:\n        throw new Error(`unsupported version: ${version}`)\n    }\n  }\n\n  private checkPrefix(str: string): void {\n    if (!str.startsWith(this.prefix)) {\n      throw new Error(`invalid public key prefix: ${this.prefix} was expected.`)\n    }\n  }\n\n  /**\n   * Initializes a new public key object from a serialized string.\n   *\n   * @param str - The serialized public key string.\n   *\n   * @returns A new public key instance.\n   *\n   * @throws If the public key prefix is invalid.\n   */\n  public static fromString(str: string): PublicKey {\n    try {\n      const version = getVersion(str)\n      const publicKey = PublicKey.initFromVersion(version)\n      publicKey.checkPrefix(str)\n      publicKey.bytes = publicKey.serializer.deserialize(\n        str.slice(publicKey.prefix.length)\n      )\n      return publicKey\n    } catch (e) {\n      throw new Error(`invalid public key string: ${e.message}`)\n    }\n  }\n\n  /**\n   * Initializes a new public key object from a byte array.\n   *\n   * @param bytes - The public key in byte format.\n   *\n   * @returns A new public key instance.\n   */\n  public static fromBytes(bytes: Uint8Array): PublicKey {\n    const version = getVersion(bytes)\n    const publicKey = PublicKey.initFromVersion(version)\n    publicKey.bytes = bytes\n    return publicKey\n  }\n\n  /**\n   * Initializes a new public key object from a private key.\n   *\n   * @param privateKey - The private key to derive the public key from.\n   *\n   * @returns A new public key instance.\n   */\n  public static async fromPrivateKey(\n    privateKey: PrivateKey\n  ): Promise<PublicKey> {\n    const publicKey = PublicKey.initFromVersion()\n    const { data } = publicKey.versioner.extract(privateKey.toBytes())\n    const publicKeyBytes = await publicKey.signer.getPublicKey(data)\n    publicKey.bytes = publicKey.versioner.attach(\n      publicKey.version,\n      publicKeyBytes\n    )\n    return publicKey\n  }\n\n  /**\n   * Get an address from the public key.\n   *\n   * @returns A new address object.\n   */\n  public getAddress(): Address {\n    return Address.fromPublicKey(this)\n  }\n\n  /**\n   * Checks the message signature with the public key.\n   *\n   * @remarks\n   * This function very a byte-encoded message. The message is first hashed and then verified.\n   * Do not pass a digest to this function as it will be hashed twice.\n   *\n   * @param signature - The signature to verify.\n   * @param data - The data signed by the signature.\n   *\n   * @returns A boolean indicating whether the signature is valid.\n   */\n  public async verify(\n    data: Uint8Array,\n    signature: Signature\n  ): Promise<boolean> {\n    const { data: rawSignature } = this.versioner.extract(signature.toBytes())\n    const { data: rawPublicKey } = this.versioner.extract(this.bytes)\n    return await this.signer.verify(\n      rawPublicKey,\n      this.hasher.hash(data),\n      rawSignature\n    )\n  }\n\n  /**\n   * Public key in bytes.\n   *\n   * @returns The versioned public key bytes.\n   */\n  public toBytes(): Uint8Array {\n    return this.bytes\n  }\n\n  /**\n   * Serializes the public key to a string.\n   *\n   * @remarks\n   * A public key is serialized as follows:\n   * - The version is serialized as a varint and prepended to the public key bytes.\n   * - The result is then sent to the serializer.\n   *\n   * @returns The serialized public key string.\n   */\n  public toString(): string {\n    return `${this.prefix}${this.serializer.serialize(this.bytes)}`\n  }\n}\n"]}