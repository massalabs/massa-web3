{"version":3,"file":"i256.js","sourceRoot":"","sources":["../../../../../src/basicElements/serializers/number/i256.ts"],"names":[],"mappings":";;;AAAA,yCAA4E;AAI/D,QAAA,SAAS,GAAG,EAAE,CAAA;AACd,QAAA,QAAQ,GAAG,GAAG,CAAA;AACd,QAAA,GAAG,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,gBAAQ,CAAC,GAAG,EAAE,CAAC,CAAC,CAAA;AACtC,QAAA,GAAG,GAAG,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,gBAAQ,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,CAAA;AAEvD;;;;;;GAMG;AACH,SAAgB,OAAO,CAAC,KAAW;IACjC,OAAO,IAAA,wBAAa,EAAC,gBAAQ,EAAE,KAAK,EAAE,IAAI,CAAC,CAAA;AAC7C,CAAC;AAFD,0BAEC;AAED;;;;;;;;GAQG;AACH,SAAgB,SAAS,CAAC,KAAiB;IACzC,OAAO,IAAA,0BAAe,EAAC,gBAAQ,EAAE,KAAK,EAAE,IAAI,CAAC,CAAA;AAC/C,CAAC;AAFD,8BAEC;AAED;;;;;GAKG;AACH,SAAgB,UAAU,CACxB,MAAkB,EAClB,MAAc;IAEd,MAAM,KAAK,GAAG,IAAA,0BAAe,EAAC,gBAAQ,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,CAAC,CAAA;IAC7D,MAAM,IAAI,iBAAS,CAAA;IACnB,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,CAAA;AAC1B,CAAC;AAPD,gCAOC;AAED;;;;;;GAMG;AACH,SAAgB,UAAU,CAAC,KAAsB;IAC/C,OAAO,IAAA,0BAAe,EAAC,gBAAQ,EAAE,KAAK,EAAE,IAAI,CAAC,CAAA;AAC/C,CAAC;AAFD,gCAEC","sourcesContent":["import { numberToInteger, integerFromByte, integerToByte } from './integers'\n\nexport type I256 = bigint\n\nexport const SIZE_BYTE = 32\nexport const SIZE_BIT = 256\nexport const MIN = -(1n << (BigInt(SIZE_BIT) - 1n))\nexport const MAX = (1n << (BigInt(SIZE_BIT) - 1n)) - 1n\n\n/**\n * Converts an I256 value to bytes\n *\n * @param value - The number to convert\n * @returns The bytes representation of the number\n * @throws if the value is out of range for I256\n */\nexport function toBytes(value: I256): Uint8Array {\n  return integerToByte(SIZE_BIT, value, true)\n}\n\n/**\n * Converts bytes to an I256 value\n *\n * @remarks\n * Silently ignores bytes that are not needed to represent the I256 value.\n *\n * @param bytes - The bytes to convert\n * @returns The I256 representation of the bytes\n */\nexport function fromBytes(bytes: Uint8Array): I256 {\n  return integerFromByte(SIZE_BIT, bytes, true)\n}\n\n/**\n * Converts an I256 value to a number\n * @param buffer - The buffer to read from\n * @param offset - The optional offset in the buffer at which to start reading the I256 value (default: 0)\n * @returns The I256 representation of the bytes\n */\nexport function fromBuffer(\n  buffer: Uint8Array,\n  offset: number\n): { value: I256; offset: number } {\n  const value = integerFromByte(SIZE_BIT, buffer, true, offset)\n  offset += SIZE_BYTE\n  return { value, offset }\n}\n\n/**\n * Converts a number to an I256 value\n *\n * @param value - The number to convert\n * @returns The I256 representation of the number\n * @throws if the value is not a safe integer or out of range for I256\n */\nexport function fromNumber(value: number | bigint): I256 {\n  return numberToInteger(SIZE_BIT, value, true)\n}\n"]}