{"version":3,"file":"i32.js","sourceRoot":"","sources":["../../../../../src/basicElements/serializers/number/i32.ts"],"names":[],"mappings":";;;AAAA,yCAA4E;AAI/D,QAAA,SAAS,GAAG,CAAC,CAAA;AACb,QAAA,QAAQ,GAAG,EAAE,CAAA;AACb,QAAA,GAAG,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,gBAAQ,CAAC,GAAG,EAAE,CAAC,CAAC,CAAA;AACtC,QAAA,GAAG,GAAG,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,gBAAQ,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,CAAA;AAEvD;;;;;;GAMG;AACH,SAAgB,OAAO,CAAC,KAAU;IAChC,OAAO,IAAA,wBAAa,EAAC,gBAAQ,EAAE,KAAK,EAAE,IAAI,CAAC,CAAA;AAC7C,CAAC;AAFD,0BAEC;AAED;;;;;;;;GAQG;AACH,SAAgB,SAAS,CAAC,KAAiB;IACzC,OAAO,IAAA,0BAAe,EAAC,gBAAQ,EAAE,KAAK,EAAE,IAAI,CAAC,CAAA;AAC/C,CAAC;AAFD,8BAEC;AAED;;;;;GAKG;AACH,SAAgB,UAAU,CACxB,MAAkB,EAClB,MAAc;IAEd,MAAM,KAAK,GAAG,IAAA,0BAAe,EAAC,gBAAQ,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,CAAC,CAAA;IAC7D,MAAM,IAAI,iBAAS,CAAA;IACnB,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,CAAA;AAC1B,CAAC;AAPD,gCAOC;AAED;;;;;;GAMG;AACH,SAAgB,UAAU,CAAC,KAAa;IACtC,OAAO,IAAA,0BAAe,EAAC,gBAAQ,EAAE,KAAK,EAAE,IAAI,CAAC,CAAA;AAC/C,CAAC;AAFD,gCAEC","sourcesContent":["import { numberToInteger, integerFromByte, integerToByte } from './integers'\n\nexport type I32 = bigint\n\nexport const SIZE_BYTE = 4\nexport const SIZE_BIT = 32\nexport const MIN = -(1n << (BigInt(SIZE_BIT) - 1n))\nexport const MAX = (1n << (BigInt(SIZE_BIT) - 1n)) - 1n\n\n/**\n * Converts an I32 value to bytes\n *\n * @param value - The number to convert\n * @returns The bytes representation of the number\n * @throws if the value is out of range for I32\n */\nexport function toBytes(value: I32): Uint8Array {\n  return integerToByte(SIZE_BIT, value, true)\n}\n\n/**\n * Converts bytes to an I32 value\n *\n * @remarks\n * Silently ignores bytes that are not needed to represent the I32 value.\n *\n * @param bytes - The bytes to convert\n * @returns The I32 representation of the bytes\n */\nexport function fromBytes(bytes: Uint8Array): I32 {\n  return integerFromByte(SIZE_BIT, bytes, true)\n}\n\n/**\n * Converts an I32 value to a number\n * @param buffer - The buffer to read from\n * @param offset - The optional offset in the buffer at which to start reading the I32 value (default: 0)\n * @returns The I32 representation of the bytes\n */\nexport function fromBuffer(\n  buffer: Uint8Array,\n  offset: number\n): { value: I32; offset: number } {\n  const value = integerFromByte(SIZE_BIT, buffer, true, offset)\n  offset += SIZE_BYTE\n  return { value, offset }\n}\n\n/**\n * Converts a number to an I32 value\n *\n * @param value - The number to convert\n * @returns The I32 representation of the number\n * @throws if the value is not a safe integer or out of range for I32\n */\nexport function fromNumber(value: number): I32 {\n  return numberToInteger(SIZE_BIT, value, true)\n}\n"]}