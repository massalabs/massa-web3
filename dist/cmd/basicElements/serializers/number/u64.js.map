{"version":3,"file":"u64.js","sourceRoot":"","sources":["../../../../../src/basicElements/serializers/number/u64.ts"],"names":[],"mappings":";;;AAAA,wBAAsB;AACtB,yCAA4E;AAI/D,QAAA,SAAS,GAAG,CAAC,CAAA;AACb,QAAA,QAAQ,GAAG,iBAAS,GAAG,KAAE,CAAC,QAAQ,CAAA;AAClC,QAAA,GAAG,GAAG,CAAC,EAAE,IAAI,MAAM,CAAC,gBAAQ,CAAC,CAAC,GAAG,EAAE,CAAA;AAEhD;;;;;;GAMG;AACH,SAAgB,OAAO,CAAC,KAAU;IAChC,OAAO,IAAA,wBAAa,EAAC,gBAAQ,EAAE,KAAK,CAAC,CAAA;AACvC,CAAC;AAFD,0BAEC;AAED;;;;;;;;GAQG;AACH,SAAgB,SAAS,CAAC,KAAiB;IACzC,OAAO,IAAA,0BAAe,EAAC,gBAAQ,EAAE,KAAK,CAAC,CAAA;AACzC,CAAC;AAFD,8BAEC;AAED;;;;;GAKG;AACH,SAAgB,UAAU,CACxB,MAAkB,EAClB,MAAc;IAEd,MAAM,KAAK,GAAG,IAAA,0BAAe,EAAC,gBAAQ,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,CAAC,CAAA;IAC9D,MAAM,IAAI,iBAAS,CAAA;IACnB,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,CAAA;AAC1B,CAAC;AAPD,gCAOC;AAED;;;;;;GAMG;AACH,SAAgB,UAAU,CAAC,KAAsB;IAC/C,OAAO,IAAA,0BAAe,EAAC,gBAAQ,EAAE,KAAK,CAAC,CAAA;AACzC,CAAC;AAFD,gCAEC","sourcesContent":["import { U8 } from '.'\nimport { numberToInteger, integerFromByte, integerToByte } from './integers'\n\nexport type U64 = bigint\n\nexport const SIZE_BYTE = 8\nexport const SIZE_BIT = SIZE_BYTE * U8.SIZE_BIT\nexport const MAX = (1n << BigInt(SIZE_BIT)) - 1n\n\n/**\n * Converts an U64 value to bytes\n *\n * @param value - The number to convert\n * @returns The bytes representation of the number\n * @throws if the value is negative or too large for U64\n */\nexport function toBytes(value: U64): Uint8Array {\n  return integerToByte(SIZE_BIT, value)\n}\n\n/**\n * Converts bytes to an U64 value\n *\n * @remarks\n * Silently ignores bytes that are not needed to represent the U8 value.\n *\n * @param bytes - The bytes to convert\n * @returns The U64 representation of the bytes\n */\nexport function fromBytes(bytes: Uint8Array): U64 {\n  return integerFromByte(SIZE_BIT, bytes)\n}\n\n/**\n * Converts an U64 value to a number\n * @param buffer - The buffer to read from\n * @param offset - The optional offset in the buffer at which to start reading the U64 value (default: 0)\n * @returns The U64 representation of the bytes\n */\nexport function fromBuffer(\n  buffer: Uint8Array,\n  offset: number\n): { value: U64; offset: number } {\n  const value = integerFromByte(SIZE_BIT, buffer, false, offset)\n  offset += SIZE_BYTE\n  return { value, offset }\n}\n\n/**\n * Converts a number to an U64 value\n *\n * @param value - The number to convert\n * @returns The U64 representation of the number\n * @throws if the value is not a safe integer, negative or too large for U64\n */\nexport function fromNumber(value: number | bigint): U64 {\n  return numberToInteger(SIZE_BIT, value)\n}\n"]}