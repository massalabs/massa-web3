// @generated by protobuf-ts 2.9.1 with parameter generate_dependencies
// @generated from protobuf file "massa/model/v1/operation.proto" (package "massa.model.v1", syntax proto3)
// tslint:disable
//
// Copyright (c) 2023 MASSA LABS <info@massa.net>
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { BytesMapFieldEntry } from "./commons";
import { NativeAmount } from "./amount";
/**
 * The operation as sent in the network
 *
 * @generated from protobuf message massa.model.v1.Operation
 */
export interface Operation {
    /**
     * The fee they have decided for this operation
     *
     * @generated from protobuf field: massa.model.v1.NativeAmount fee = 1;
     */
    fee?: NativeAmount;
    /**
     * After `expire_period` slot the operation won't be included in a block
     *
     * @generated from protobuf field: uint64 expire_period = 2;
     */
    expirePeriod: bigint;
    /**
     * The type specific operation part
     *
     * @generated from protobuf field: massa.model.v1.OperationType op = 3;
     */
    op?: OperationType;
}
/**
 * Type specific operation content
 *
 * @generated from protobuf message massa.model.v1.OperationType
 */
export interface OperationType {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "transaction";
        /**
         * Transfer coins from sender to recipient
         *
         * @generated from protobuf field: massa.model.v1.Transaction transaction = 1;
         */
        transaction: Transaction;
    } | {
        oneofKind: "rollBuy";
        /**
         * The sender buys `roll_count` rolls. Roll price is defined in configuration
         *
         * @generated from protobuf field: massa.model.v1.RollBuy roll_buy = 2;
         */
        rollBuy: RollBuy;
    } | {
        oneofKind: "rollSell";
        /**
         * The sender sells `roll_count` rolls. Roll price is defined in configuration
         *
         * @generated from protobuf field: massa.model.v1.RollSell roll_sell = 3;
         */
        rollSell: RollSell;
    } | {
        oneofKind: "executSc";
        /**
         * Execute a smart contract
         *
         * @generated from protobuf field: massa.model.v1.ExecuteSC execut_sc = 4;
         */
        executSc: ExecuteSC;
    } | {
        oneofKind: "callSc";
        /**
         * Calls an exported function from a stored smart contract
         *
         * @generated from protobuf field: massa.model.v1.CallSC call_sc = 5;
         */
        callSc: CallSC;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Transfer coins from sender to recipient
 *
 * @generated from protobuf message massa.model.v1.Transaction
 */
export interface Transaction {
    /**
     * Recipient address
     *
     * @generated from protobuf field: string recipient_address = 1;
     */
    recipientAddress: string;
    /**
     * Amount
     *
     * @generated from protobuf field: massa.model.v1.NativeAmount amount = 2;
     */
    amount?: NativeAmount;
}
/**
 * The sender buys `roll_count` rolls. Roll price is defined in configuration
 *
 * @generated from protobuf message massa.model.v1.RollBuy
 */
export interface RollBuy {
    /**
     * Roll count
     *
     * @generated from protobuf field: uint64 roll_count = 1;
     */
    rollCount: bigint;
}
/**
 * The sender sells `roll_count` rolls. Roll price is defined in configuration
 *
 * @generated from protobuf message massa.model.v1.RollSell
 */
export interface RollSell {
    /**
     * Roll count
     *
     * @generated from protobuf field: uint64 roll_count = 1;
     */
    rollCount: bigint;
}
/**
 * Execute a smart contract
 *
 * @generated from protobuf message massa.model.v1.ExecuteSC
 */
export interface ExecuteSC {
    /**
     * Smart contract bytecode.
     *
     * @generated from protobuf field: bytes data = 1;
     */
    data: Uint8Array;
    /**
     * The maximum of coins that could be spent by the operation sender
     *
     * @generated from protobuf field: uint64 max_coins = 2;
     */
    maxCoins: bigint;
    /**
     * The maximum amount of gas that the execution of the contract is allowed to cost
     *
     * @generated from protobuf field: uint64 max_gas = 3;
     */
    maxGas: bigint;
    /**
     * A key-value store associating a hash to arbitrary bytes
     *
     * @generated from protobuf field: repeated massa.model.v1.BytesMapFieldEntry datastore = 4;
     */
    datastore: BytesMapFieldEntry[];
}
/**
 * Calls an exported function from a stored smart contract
 *
 * @generated from protobuf message massa.model.v1.CallSC
 */
export interface CallSC {
    /**
     * Target smart contract address
     *
     * @generated from protobuf field: string target_address = 1;
     */
    targetAddress: string;
    /**
     * Target function name. No function is called if empty
     *
     * @generated from protobuf field: string target_function = 2;
     */
    targetFunction: string;
    /**
     * Parameter to pass to the target function
     *
     * @generated from protobuf field: bytes parameter = 3;
     */
    parameter: Uint8Array;
    /**
     * The maximum amount of gas that the execution of the contract is allowed to cost
     *
     * @generated from protobuf field: uint64 max_gas = 4;
     */
    maxGas: bigint;
    /**
     * Extra coins that are spent from the caller's balance and transferred to the target
     *
     * @generated from protobuf field: massa.model.v1.NativeAmount coins = 5;
     */
    coins?: NativeAmount;
}
/**
 * Signed operation
 *
 * @generated from protobuf message massa.model.v1.SignedOperation
 */
export interface SignedOperation {
    /**
     * Operation
     *
     * @generated from protobuf field: massa.model.v1.Operation content = 1;
     */
    content?: Operation;
    /**
     * A cryptographically generated value using `serialized_data` and a public key.
     *
     * @generated from protobuf field: string signature = 2;
     */
    signature: string;
    /**
     * The public-key component used in the generation of the signature
     *
     * @generated from protobuf field: string content_creator_pub_key = 3;
     */
    contentCreatorPubKey: string;
    /**
     * Derived from the same public key used to generate the signature
     *
     * @generated from protobuf field: string content_creator_address = 4;
     */
    contentCreatorAddress: string;
    /**
     * A secure hash of the non-malleable contents of a deterministic binary representation of the block header
     *
     * @generated from protobuf field: string secure_hash = 5;
     */
    secureHash: string;
    /**
     * The size of the serialized operation in bytes
     *
     * @generated from protobuf field: uint64 serialized_size = 6;
     */
    serializedSize: bigint;
}
/**
 * A wrapper around an operation with its metadata
 *
 * @generated from protobuf message massa.model.v1.OperationWrapper
 */
export interface OperationWrapper {
    /**
     * The IDs of the blocks in which the operation appears
     *
     * @generated from protobuf field: repeated string block_ids = 1;
     */
    blockIds: string[];
    /**
     * The thread in which the operation can be included
     *
     * @generated from protobuf field: uint32 thread = 2;
     */
    thread: number;
    /**
     * The operation object itself
     *
     * @generated from protobuf field: massa.model.v1.SignedOperation operation = 3;
     */
    operation?: SignedOperation;
}
/**
 * Information about an operation with its metadata
 *
 * @generated from protobuf message massa.model.v1.OperationInfo
 */
export interface OperationInfo {
    /**
     * The unique ID of the operation.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * The IDs of the blocks in which the operation appears
     *
     * @generated from protobuf field: repeated string block_ids = 2;
     */
    blockIds: string[];
    /**
     * The thread in which the operation can be included
     *
     * @generated from protobuf field: uint32 thread = 3;
     */
    thread: number;
}
/**
 * OperationIds
 *
 * @generated from protobuf message massa.model.v1.OperationIds
 */
export interface OperationIds {
    /**
     * Operations ids
     *
     * @generated from protobuf field: repeated string operation_ids = 1;
     */
    operationIds: string[];
}
/**
 * OpTypes
 *
 * @generated from protobuf message massa.model.v1.OpTypes
 */
export interface OpTypes {
    /**
     * Operations types
     *
     * @generated from protobuf field: repeated massa.model.v1.OpType op_types = 1;
     */
    opTypes: OpType[];
}
/**
 * Operation type enum
 *
 * @generated from protobuf enum massa.model.v1.OpType
 */
export enum OpType {
    /**
     * Default enum value
     *
     * @generated from protobuf enum value: OP_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Transaction
     *
     * @generated from protobuf enum value: OP_TYPE_TRANSACTION = 1;
     */
    TRANSACTION = 1,
    /**
     * Roll buy
     *
     * @generated from protobuf enum value: OP_TYPE_ROLL_BUY = 2;
     */
    ROLL_BUY = 2,
    /**
     * Roll sell
     *
     * @generated from protobuf enum value: OP_TYPE_ROLL_SELL = 3;
     */
    ROLL_SELL = 3,
    /**
     * Execute smart contract
     *
     * @generated from protobuf enum value: OP_TYPE_EXECUTE_SC = 4;
     */
    EXECUTE_SC = 4,
    /**
     * Call smart contract
     *
     * @generated from protobuf enum value: OP_TYPE_CALL_SC = 5;
     */
    CALL_SC = 5
}
// @generated message type with reflection information, may provide speed optimized methods
class Operation$Type extends MessageType<Operation> {
    constructor() {
        super("massa.model.v1.Operation", [
            { no: 1, name: "fee", kind: "message", T: () => NativeAmount },
            { no: 2, name: "expire_period", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "op", kind: "message", T: () => OperationType }
        ]);
    }
    create(value?: PartialMessage<Operation>): Operation {
        const message = { expirePeriod: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Operation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Operation): Operation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* massa.model.v1.NativeAmount fee */ 1:
                    message.fee = NativeAmount.internalBinaryRead(reader, reader.uint32(), options, message.fee);
                    break;
                case /* uint64 expire_period */ 2:
                    message.expirePeriod = reader.uint64().toBigInt();
                    break;
                case /* massa.model.v1.OperationType op */ 3:
                    message.op = OperationType.internalBinaryRead(reader, reader.uint32(), options, message.op);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Operation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* massa.model.v1.NativeAmount fee = 1; */
        if (message.fee)
            NativeAmount.internalBinaryWrite(message.fee, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 expire_period = 2; */
        if (message.expirePeriod !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.expirePeriod);
        /* massa.model.v1.OperationType op = 3; */
        if (message.op)
            OperationType.internalBinaryWrite(message.op, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.Operation
 */
export const Operation = new Operation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OperationType$Type extends MessageType<OperationType> {
    constructor() {
        super("massa.model.v1.OperationType", [
            { no: 1, name: "transaction", kind: "message", oneof: "type", T: () => Transaction },
            { no: 2, name: "roll_buy", kind: "message", oneof: "type", T: () => RollBuy },
            { no: 3, name: "roll_sell", kind: "message", oneof: "type", T: () => RollSell },
            { no: 4, name: "execut_sc", kind: "message", oneof: "type", T: () => ExecuteSC },
            { no: 5, name: "call_sc", kind: "message", oneof: "type", T: () => CallSC }
        ]);
    }
    create(value?: PartialMessage<OperationType>): OperationType {
        const message = { type: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OperationType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OperationType): OperationType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* massa.model.v1.Transaction transaction */ 1:
                    message.type = {
                        oneofKind: "transaction",
                        transaction: Transaction.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).transaction)
                    };
                    break;
                case /* massa.model.v1.RollBuy roll_buy */ 2:
                    message.type = {
                        oneofKind: "rollBuy",
                        rollBuy: RollBuy.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).rollBuy)
                    };
                    break;
                case /* massa.model.v1.RollSell roll_sell */ 3:
                    message.type = {
                        oneofKind: "rollSell",
                        rollSell: RollSell.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).rollSell)
                    };
                    break;
                case /* massa.model.v1.ExecuteSC execut_sc */ 4:
                    message.type = {
                        oneofKind: "executSc",
                        executSc: ExecuteSC.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).executSc)
                    };
                    break;
                case /* massa.model.v1.CallSC call_sc */ 5:
                    message.type = {
                        oneofKind: "callSc",
                        callSc: CallSC.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).callSc)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OperationType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* massa.model.v1.Transaction transaction = 1; */
        if (message.type.oneofKind === "transaction")
            Transaction.internalBinaryWrite(message.type.transaction, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.RollBuy roll_buy = 2; */
        if (message.type.oneofKind === "rollBuy")
            RollBuy.internalBinaryWrite(message.type.rollBuy, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.RollSell roll_sell = 3; */
        if (message.type.oneofKind === "rollSell")
            RollSell.internalBinaryWrite(message.type.rollSell, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.ExecuteSC execut_sc = 4; */
        if (message.type.oneofKind === "executSc")
            ExecuteSC.internalBinaryWrite(message.type.executSc, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.CallSC call_sc = 5; */
        if (message.type.oneofKind === "callSc")
            CallSC.internalBinaryWrite(message.type.callSc, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.OperationType
 */
export const OperationType = new OperationType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Transaction$Type extends MessageType<Transaction> {
    constructor() {
        super("massa.model.v1.Transaction", [
            { no: 1, name: "recipient_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "message", T: () => NativeAmount }
        ]);
    }
    create(value?: PartialMessage<Transaction>): Transaction {
        const message = { recipientAddress: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Transaction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Transaction): Transaction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string recipient_address */ 1:
                    message.recipientAddress = reader.string();
                    break;
                case /* massa.model.v1.NativeAmount amount */ 2:
                    message.amount = NativeAmount.internalBinaryRead(reader, reader.uint32(), options, message.amount);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Transaction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string recipient_address = 1; */
        if (message.recipientAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.recipientAddress);
        /* massa.model.v1.NativeAmount amount = 2; */
        if (message.amount)
            NativeAmount.internalBinaryWrite(message.amount, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.Transaction
 */
export const Transaction = new Transaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RollBuy$Type extends MessageType<RollBuy> {
    constructor() {
        super("massa.model.v1.RollBuy", [
            { no: 1, name: "roll_count", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RollBuy>): RollBuy {
        const message = { rollCount: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RollBuy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RollBuy): RollBuy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 roll_count */ 1:
                    message.rollCount = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RollBuy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 roll_count = 1; */
        if (message.rollCount !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.rollCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.RollBuy
 */
export const RollBuy = new RollBuy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RollSell$Type extends MessageType<RollSell> {
    constructor() {
        super("massa.model.v1.RollSell", [
            { no: 1, name: "roll_count", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RollSell>): RollSell {
        const message = { rollCount: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RollSell>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RollSell): RollSell {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 roll_count */ 1:
                    message.rollCount = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RollSell, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 roll_count = 1; */
        if (message.rollCount !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.rollCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.RollSell
 */
export const RollSell = new RollSell$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteSC$Type extends MessageType<ExecuteSC> {
    constructor() {
        super("massa.model.v1.ExecuteSC", [
            { no: 1, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "max_coins", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "max_gas", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "datastore", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BytesMapFieldEntry }
        ]);
    }
    create(value?: PartialMessage<ExecuteSC>): ExecuteSC {
        const message = { data: new Uint8Array(0), maxCoins: 0n, maxGas: 0n, datastore: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExecuteSC>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteSC): ExecuteSC {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                case /* uint64 max_coins */ 2:
                    message.maxCoins = reader.uint64().toBigInt();
                    break;
                case /* uint64 max_gas */ 3:
                    message.maxGas = reader.uint64().toBigInt();
                    break;
                case /* repeated massa.model.v1.BytesMapFieldEntry datastore */ 4:
                    message.datastore.push(BytesMapFieldEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteSC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes data = 1; */
        if (message.data.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        /* uint64 max_coins = 2; */
        if (message.maxCoins !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.maxCoins);
        /* uint64 max_gas = 3; */
        if (message.maxGas !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.maxGas);
        /* repeated massa.model.v1.BytesMapFieldEntry datastore = 4; */
        for (let i = 0; i < message.datastore.length; i++)
            BytesMapFieldEntry.internalBinaryWrite(message.datastore[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.ExecuteSC
 */
export const ExecuteSC = new ExecuteSC$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CallSC$Type extends MessageType<CallSC> {
    constructor() {
        super("massa.model.v1.CallSC", [
            { no: 1, name: "target_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target_function", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "parameter", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "max_gas", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "coins", kind: "message", T: () => NativeAmount }
        ]);
    }
    create(value?: PartialMessage<CallSC>): CallSC {
        const message = { targetAddress: "", targetFunction: "", parameter: new Uint8Array(0), maxGas: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CallSC>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CallSC): CallSC {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string target_address */ 1:
                    message.targetAddress = reader.string();
                    break;
                case /* string target_function */ 2:
                    message.targetFunction = reader.string();
                    break;
                case /* bytes parameter */ 3:
                    message.parameter = reader.bytes();
                    break;
                case /* uint64 max_gas */ 4:
                    message.maxGas = reader.uint64().toBigInt();
                    break;
                case /* massa.model.v1.NativeAmount coins */ 5:
                    message.coins = NativeAmount.internalBinaryRead(reader, reader.uint32(), options, message.coins);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CallSC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string target_address = 1; */
        if (message.targetAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.targetAddress);
        /* string target_function = 2; */
        if (message.targetFunction !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.targetFunction);
        /* bytes parameter = 3; */
        if (message.parameter.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.parameter);
        /* uint64 max_gas = 4; */
        if (message.maxGas !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.maxGas);
        /* massa.model.v1.NativeAmount coins = 5; */
        if (message.coins)
            NativeAmount.internalBinaryWrite(message.coins, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.CallSC
 */
export const CallSC = new CallSC$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignedOperation$Type extends MessageType<SignedOperation> {
    constructor() {
        super("massa.model.v1.SignedOperation", [
            { no: 1, name: "content", kind: "message", T: () => Operation },
            { no: 2, name: "signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "content_creator_pub_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "content_creator_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "secure_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "serialized_size", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SignedOperation>): SignedOperation {
        const message = { signature: "", contentCreatorPubKey: "", contentCreatorAddress: "", secureHash: "", serializedSize: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SignedOperation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignedOperation): SignedOperation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* massa.model.v1.Operation content */ 1:
                    message.content = Operation.internalBinaryRead(reader, reader.uint32(), options, message.content);
                    break;
                case /* string signature */ 2:
                    message.signature = reader.string();
                    break;
                case /* string content_creator_pub_key */ 3:
                    message.contentCreatorPubKey = reader.string();
                    break;
                case /* string content_creator_address */ 4:
                    message.contentCreatorAddress = reader.string();
                    break;
                case /* string secure_hash */ 5:
                    message.secureHash = reader.string();
                    break;
                case /* uint64 serialized_size */ 6:
                    message.serializedSize = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignedOperation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* massa.model.v1.Operation content = 1; */
        if (message.content)
            Operation.internalBinaryWrite(message.content, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string signature = 2; */
        if (message.signature !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.signature);
        /* string content_creator_pub_key = 3; */
        if (message.contentCreatorPubKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.contentCreatorPubKey);
        /* string content_creator_address = 4; */
        if (message.contentCreatorAddress !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.contentCreatorAddress);
        /* string secure_hash = 5; */
        if (message.secureHash !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.secureHash);
        /* uint64 serialized_size = 6; */
        if (message.serializedSize !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.serializedSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.SignedOperation
 */
export const SignedOperation = new SignedOperation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OperationWrapper$Type extends MessageType<OperationWrapper> {
    constructor() {
        super("massa.model.v1.OperationWrapper", [
            { no: 1, name: "block_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "thread", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "operation", kind: "message", T: () => SignedOperation }
        ]);
    }
    create(value?: PartialMessage<OperationWrapper>): OperationWrapper {
        const message = { blockIds: [], thread: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OperationWrapper>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OperationWrapper): OperationWrapper {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string block_ids */ 1:
                    message.blockIds.push(reader.string());
                    break;
                case /* uint32 thread */ 2:
                    message.thread = reader.uint32();
                    break;
                case /* massa.model.v1.SignedOperation operation */ 3:
                    message.operation = SignedOperation.internalBinaryRead(reader, reader.uint32(), options, message.operation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OperationWrapper, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string block_ids = 1; */
        for (let i = 0; i < message.blockIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.blockIds[i]);
        /* uint32 thread = 2; */
        if (message.thread !== 0)
            writer.tag(2, WireType.Varint).uint32(message.thread);
        /* massa.model.v1.SignedOperation operation = 3; */
        if (message.operation)
            SignedOperation.internalBinaryWrite(message.operation, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.OperationWrapper
 */
export const OperationWrapper = new OperationWrapper$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OperationInfo$Type extends MessageType<OperationInfo> {
    constructor() {
        super("massa.model.v1.OperationInfo", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "block_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "thread", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<OperationInfo>): OperationInfo {
        const message = { id: "", blockIds: [], thread: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OperationInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OperationInfo): OperationInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* repeated string block_ids */ 2:
                    message.blockIds.push(reader.string());
                    break;
                case /* uint32 thread */ 3:
                    message.thread = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OperationInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* repeated string block_ids = 2; */
        for (let i = 0; i < message.blockIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.blockIds[i]);
        /* uint32 thread = 3; */
        if (message.thread !== 0)
            writer.tag(3, WireType.Varint).uint32(message.thread);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.OperationInfo
 */
export const OperationInfo = new OperationInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OperationIds$Type extends MessageType<OperationIds> {
    constructor() {
        super("massa.model.v1.OperationIds", [
            { no: 1, name: "operation_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OperationIds>): OperationIds {
        const message = { operationIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OperationIds>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OperationIds): OperationIds {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string operation_ids */ 1:
                    message.operationIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OperationIds, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string operation_ids = 1; */
        for (let i = 0; i < message.operationIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.operationIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.OperationIds
 */
export const OperationIds = new OperationIds$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OpTypes$Type extends MessageType<OpTypes> {
    constructor() {
        super("massa.model.v1.OpTypes", [
            { no: 1, name: "op_types", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["massa.model.v1.OpType", OpType, "OP_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<OpTypes>): OpTypes {
        const message = { opTypes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OpTypes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpTypes): OpTypes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated massa.model.v1.OpType op_types */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.opTypes.push(reader.int32());
                    else
                        message.opTypes.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OpTypes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated massa.model.v1.OpType op_types = 1; */
        if (message.opTypes.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.opTypes.length; i++)
                writer.int32(message.opTypes[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.OpTypes
 */
export const OpTypes = new OpTypes$Type();
