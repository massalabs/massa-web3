// @generated by protobuf-ts 2.9.1 with parameter generate_dependencies
// @generated from protobuf file "massa/model/v1/execution.proto" (package "massa.model.v1", syntax proto3)
// tslint:disable
//
// Copyright (c) 2023 MASSA LABS <info@massa.net>
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { BytesMapFieldEntry } from "./commons";
import { BoolValue } from "../../../google/protobuf/wrappers";
import { BytesValue } from "../../../google/protobuf/wrappers";
import { UInt64Value } from "../../../google/protobuf/wrappers";
import { Empty } from "./commons";
import { NativeAmount } from "./amount";
import { DenunciationIndex } from "./denunciation";
import { StringValue } from "../../../google/protobuf/wrappers";
import { Slot } from "./slot";
/**
 * SlotExecutionOutput
 *
 * @generated from protobuf message massa.model.v1.SlotExecutionOutput
 */
export interface SlotExecutionOutput {
    /**
     * Status
     *
     * @generated from protobuf field: massa.model.v1.ExecutionOutputStatus status = 1;
     */
    status: ExecutionOutputStatus;
    /**
     * Executed slot output
     *
     * @generated from protobuf field: massa.model.v1.ExecutionOutput execution_output = 2;
     */
    executionOutput?: ExecutionOutput;
}
/**
 * FinalizedExecutionOutput
 *
 * @generated from protobuf message massa.model.v1.FinalizedExecutionOutput
 */
export interface FinalizedExecutionOutput {
    /**
     * Slot
     *
     * @generated from protobuf field: massa.model.v1.Slot slot = 1;
     */
    slot?: Slot;
}
/**
 * ExecutionOutput
 *
 * @generated from protobuf message massa.model.v1.ExecutionOutput
 */
export interface ExecutionOutput {
    /**
     * Slot
     *
     * @generated from protobuf field: massa.model.v1.Slot slot = 1;
     */
    slot?: Slot;
    /**
     * Block id at that slot (Optional)
     *
     * @generated from protobuf field: google.protobuf.StringValue block_id = 2;
     */
    blockId?: StringValue;
    /**
     * Events emitted by the execution step
     *
     * @generated from protobuf field: repeated massa.model.v1.ScExecutionEvent events = 3;
     */
    events: ScExecutionEvent[];
    /**
     * State changes caused by the execution step
     *
     * @generated from protobuf field: massa.model.v1.StateChanges state_changes = 4;
     */
    stateChanges?: StateChanges;
}
/**
 * ScExecutionEvent
 *
 * @generated from protobuf message massa.model.v1.ScExecutionEvent
 */
export interface ScExecutionEvent {
    /**
     * Sc execution context
     *
     * @generated from protobuf field: massa.model.v1.ScExecutionEventContext context = 1;
     */
    context?: ScExecutionEventContext;
    /**
     * Generated data of the event
     *
     * @generated from protobuf field: bytes data = 2;
     */
    data: Uint8Array;
}
/**
 * ScExecutionEvent context
 *
 * @generated from protobuf message massa.model.v1.ScExecutionEventContext
 */
export interface ScExecutionEventContext {
    /**
     * When was it generated
     *
     * @generated from protobuf field: massa.model.v1.Slot origin_slot = 1;
     */
    originSlot?: Slot;
    /**
     * Block id if there was a block at that slot (Optional)
     *
     * @generated from protobuf field: google.protobuf.StringValue block_id = 2;
     */
    blockId?: StringValue;
    /**
     * Index of the event in the slot
     *
     * @generated from protobuf field: uint64 index_in_slot = 3;
     */
    indexInSlot: bigint;
    /**
     * Call stack addresses. most recent at the end
     *
     * @generated from protobuf field: repeated string call_stack = 4;
     */
    callStack: string[];
    /**
     * Origin operation id (Optional)
     *
     * @generated from protobuf field: google.protobuf.StringValue origin_operation_id = 5;
     */
    originOperationId?: StringValue;
    /**
     * If a failure occurred
     *
     * @generated from protobuf field: bool is_failure = 6;
     */
    isFailure: boolean;
    /**
     * Status
     *
     * @generated from protobuf field: massa.model.v1.ScExecutionEventStatus status = 7;
     */
    status: ScExecutionEventStatus;
}
/**
 * ScExecutionEventsStatus
 *
 * @generated from protobuf message massa.model.v1.ScExecutionEventsStatus
 */
export interface ScExecutionEventsStatus {
    /**
     * Status
     *
     * @generated from protobuf field: repeated massa.model.v1.ScExecutionEventStatus status = 1;
     */
    status: ScExecutionEventStatus[];
}
/**
 * StateChanges
 *
 * @generated from protobuf message massa.model.v1.StateChanges
 */
export interface StateChanges {
    /**
     * Ledger changes
     *
     * @generated from protobuf field: repeated massa.model.v1.LedgerChangeEntry ledger_changes = 1;
     */
    ledgerChanges: LedgerChangeEntry[];
    /**
     * Asynchronous pool changes
     *
     * @generated from protobuf field: repeated massa.model.v1.AsyncPoolChangeEntry async_pool_changes = 2;
     */
    asyncPoolChanges: AsyncPoolChangeEntry[];
    /**
     * Executed operations changes
     *
     * @generated from protobuf field: repeated massa.model.v1.ExecutedOpsChangeEntry executed_ops_changes = 4;
     */
    executedOpsChanges: ExecutedOpsChangeEntry[];
    /**
     * Executed denunciations changes
     *
     * @generated from protobuf field: repeated massa.model.v1.DenunciationIndex executed_denunciations_changes = 5;
     */
    executedDenunciationsChanges: DenunciationIndex[];
    /**
     * Execution trail hash change
     *
     * @generated from protobuf field: massa.model.v1.SetOrKeepString execution_trail_hash_change = 6;
     */
    executionTrailHashChange?: SetOrKeepString;
}
/**
 * ExecutedOpsChangeEntry
 *
 * @generated from protobuf message massa.model.v1.ExecutedOpsChangeEntry
 */
export interface ExecutedOpsChangeEntry {
    /**
     * string
     *
     * @generated from protobuf field: string operation_id = 1;
     */
    operationId: string;
    /**
     * ExecutedOpsChangeValue
     *
     * @generated from protobuf field: massa.model.v1.ExecutedOpsChangeValue value = 2;
     */
    value?: ExecutedOpsChangeValue;
}
/**
 * ExecutedOpsChangeValue
 *
 * @generated from protobuf message massa.model.v1.ExecutedOpsChangeValue
 */
export interface ExecutedOpsChangeValue {
    /**
     * The status of the execution of the operation
     *
     * @generated from protobuf field: massa.model.v1.OperationExecutionStatus status = 1;
     */
    status: OperationExecutionStatus;
    /**
     * Slot until which the operation remains valid (included)
     *
     * @generated from protobuf field: massa.model.v1.Slot slot = 2;
     */
    slot?: Slot;
}
/**
 * AsyncPoolChange Entry
 *
 * @generated from protobuf message massa.model.v1.AsyncPoolChangeEntry
 */
export interface AsyncPoolChangeEntry {
    /**
     * Async message id
     *
     * @generated from protobuf field: string async_message_id = 1;
     */
    asyncMessageId: string;
    /**
     * AsyncPool message
     *
     * @generated from protobuf field: massa.model.v1.AsyncPoolChangeValue value = 2;
     */
    value?: AsyncPoolChangeValue;
}
/**
 * AsyncPoolChangeValue
 *
 * @generated from protobuf message massa.model.v1.AsyncPoolChangeValue
 */
export interface AsyncPoolChangeValue {
    /**
     * The type of the change
     *
     * @generated from protobuf field: massa.model.v1.AsyncPoolChangeType type = 1;
     */
    type: AsyncPoolChangeType;
    /**
     * @generated from protobuf oneof: message
     */
    message: {
        oneofKind: "createdMessage";
        /**
         * Created ledger entry
         *
         * @generated from protobuf field: massa.model.v1.AsyncMessage created_message = 2;
         */
        createdMessage: AsyncMessage;
    } | {
        oneofKind: "updatedMessage";
        /**
         * Update ledger entry
         *
         * @generated from protobuf field: massa.model.v1.AsyncMessageUpdate updated_message = 3;
         */
        updatedMessage: AsyncMessageUpdate;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Asynchronous smart contract message
 *
 * @generated from protobuf message massa.model.v1.AsyncMessage
 */
export interface AsyncMessage {
    /**
     * Slot at which the message was emitted
     *
     * @generated from protobuf field: massa.model.v1.Slot emission_slot = 1;
     */
    emissionSlot?: Slot;
    /**
     * Index of the emitted message within the `emission_slot`.
     * This is used for disambiguate the emission of multiple messages at the same slot.
     *
     * @generated from protobuf field: uint64 emission_index = 2;
     */
    emissionIndex: bigint;
    /**
     * The address that sent the message
     *
     * @generated from protobuf field: string sender = 3;
     */
    sender: string;
    /**
     * The address towards which the message is being sent
     *
     * @generated from protobuf field: string destination = 4;
     */
    destination: string;
    /**
     * the handler function name within the destination address' bytecode
     *
     * @generated from protobuf field: string handler = 5;
     */
    handler: string;
    /**
     * Maximum gas to use when processing the message
     *
     * @generated from protobuf field: uint64 max_gas = 6;
     */
    maxGas: bigint;
    /**
     * Fee paid by the sender when the message is processed.
     *
     * @generated from protobuf field: massa.model.v1.NativeAmount fee = 7;
     */
    fee?: NativeAmount;
    /**
     * Coins sent from the sender to the target address of the message.
     * Those coins are spent by the sender address when the message is sent,
     * and credited to the destination address when receiving the message.
     * In case of failure or discard, those coins are reimbursed to the sender.
     *
     * @generated from protobuf field: massa.model.v1.NativeAmount coins = 8;
     */
    coins?: NativeAmount;
    /**
     * Slot at which the message starts being valid (bound included in the validity range)
     *
     * @generated from protobuf field: massa.model.v1.Slot validity_start = 9;
     */
    validityStart?: Slot;
    /**
     * Slot at which the message stops being valid (bound not included in the validity range)
     *
     * @generated from protobuf field: massa.model.v1.Slot validity_end = 10;
     */
    validityEnd?: Slot;
    /**
     * Raw payload data of the message
     *
     * @generated from protobuf field: bytes data = 11;
     */
    data: Uint8Array;
    /**
     * Trigger that define whenever a message can be executed
     *
     * @generated from protobuf field: massa.model.v1.AsyncMessageTrigger trigger = 12;
     */
    trigger?: AsyncMessageTrigger;
    /**
     * Boolean that determine if the message can be executed. For messages without filter this boolean is always true.
     * For messages with filter, this boolean is true if the filter has been matched between `validity_start` and current slot.
     *
     * @generated from protobuf field: bool can_be_executed = 13;
     */
    canBeExecuted: boolean;
}
/**
 * Asynchronous smart contract message
 *
 * @generated from protobuf message massa.model.v1.AsyncMessageUpdate
 */
export interface AsyncMessageUpdate {
    /**
     * Change the slot at which the message was emitted
     *
     * @generated from protobuf field: massa.model.v1.SetOrKeepSlot emission_slot = 1;
     */
    emissionSlot?: SetOrKeepSlot;
    /**
     * Change the index of the emitted message within the `emission_slot`.
     * This is used for disambiguate the emission of multiple messages at the same slot.
     *
     * @generated from protobuf field: massa.model.v1.SetOrKeepUint64 emission_index = 2;
     */
    emissionIndex?: SetOrKeepUint64;
    /**
     * Change the address that sent the message
     *
     * @generated from protobuf field: massa.model.v1.SetOrKeepString sender = 3;
     */
    sender?: SetOrKeepString;
    /**
     * Change the address towards which the message is being sent
     *
     * @generated from protobuf field: massa.model.v1.SetOrKeepString destination = 4;
     */
    destination?: SetOrKeepString;
    /**
     * Change the handler function name within the destination address' bytecode
     *
     * @generated from protobuf field: massa.model.v1.SetOrKeepString handler = 5;
     */
    handler?: SetOrKeepString;
    /**
     * Change the maximum gas to use when processing the message
     *
     * @generated from protobuf field: massa.model.v1.SetOrKeepUint64 max_gas = 6;
     */
    maxGas?: SetOrKeepUint64;
    /**
     * Change the fee paid by the sender when the message is processed.
     *
     * @generated from protobuf field: massa.model.v1.SetOrKeepUint64 fee = 7;
     */
    fee?: SetOrKeepUint64;
    /**
     * Change the coins sent from the sender to the target address of the message.
     * Those coins are spent by the sender address when the message is sent,
     * and credited to the destination address when receiving the message.
     * In case of failure or discard, those coins are reimbursed to the sender.
     *
     * @generated from protobuf field: massa.model.v1.SetOrKeepUint64 coins = 8;
     */
    coins?: SetOrKeepUint64;
    /**
     * Change the slot at which the message starts being valid (bound included in the validity range)
     *
     * @generated from protobuf field: massa.model.v1.SetOrKeepSlot validity_start = 9;
     */
    validityStart?: SetOrKeepSlot;
    /**
     * Change the slot at which the message stops being valid (bound not included in the validity range)
     *
     * @generated from protobuf field: massa.model.v1.SetOrKeepSlot validity_end = 10;
     */
    validityEnd?: SetOrKeepSlot;
    /**
     * Change the raw payload data of the message
     *
     * @generated from protobuf field: massa.model.v1.SetOrKeepBytes data = 11;
     */
    data?: SetOrKeepBytes;
    /**
     * Change the trigger that define whenever a message can be executed
     *
     * @generated from protobuf field: massa.model.v1.SetOrKeepAsyncMessageTrigger trigger = 12;
     */
    trigger?: SetOrKeepAsyncMessageTrigger;
    /**
     * Change the boolean that determine if the message can be executed. For messages without filter this boolean is always true.
     * For messages with filter, this boolean is true if the filter has been matched between `validity_start` and current slot.
     *
     * @generated from protobuf field: massa.model.v1.SetOrKeepBool can_be_executed = 13;
     */
    canBeExecuted?: SetOrKeepBool;
}
/**
 * Set or Keep Slot
 *
 * @generated from protobuf message massa.model.v1.SetOrKeepSlot
 */
export interface SetOrKeepSlot {
    /**
     * @generated from protobuf oneof: change
     */
    change: {
        oneofKind: "set";
        /**
         * The value of that entry (Optional)
         *
         * @generated from protobuf field: massa.model.v1.Slot set = 1;
         */
        set: Slot;
    } | {
        oneofKind: "keep";
        /**
         * Keep the existing value
         *
         * @generated from protobuf field: massa.model.v1.Empty keep = 2;
         */
        keep: Empty;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Set or Keep Uint64
 *
 * @generated from protobuf message massa.model.v1.SetOrKeepUint64
 */
export interface SetOrKeepUint64 {
    /**
     * @generated from protobuf oneof: change
     */
    change: {
        oneofKind: "set";
        /**
         * The value of that entry (Optional)
         *
         * @generated from protobuf field: google.protobuf.UInt64Value set = 1;
         */
        set: UInt64Value;
    } | {
        oneofKind: "keep";
        /**
         * Keep the existing value
         *
         * @generated from protobuf field: massa.model.v1.Empty keep = 2;
         */
        keep: Empty;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Set or Keep String
 *
 * @generated from protobuf message massa.model.v1.SetOrKeepString
 */
export interface SetOrKeepString {
    /**
     * @generated from protobuf oneof: change
     */
    change: {
        oneofKind: "set";
        /**
         * The value of that entry (Optional)
         *
         * @generated from protobuf field: google.protobuf.StringValue set = 1;
         */
        set: StringValue;
    } | {
        oneofKind: "keep";
        /**
         * Keep the existing value
         *
         * @generated from protobuf field: massa.model.v1.Empty keep = 2;
         */
        keep: Empty;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Set or Keep Bytes
 *
 * @generated from protobuf message massa.model.v1.SetOrKeepBytes
 */
export interface SetOrKeepBytes {
    /**
     * @generated from protobuf oneof: change
     */
    change: {
        oneofKind: "set";
        /**
         * The value of that entry (Optional)
         *
         * @generated from protobuf field: google.protobuf.BytesValue set = 1;
         */
        set: BytesValue;
    } | {
        oneofKind: "keep";
        /**
         * Keep the existing value
         *
         * @generated from protobuf field: massa.model.v1.Empty keep = 2;
         */
        keep: Empty;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Set or Keep Bool
 *
 * @generated from protobuf message massa.model.v1.SetOrKeepBool
 */
export interface SetOrKeepBool {
    /**
     * @generated from protobuf oneof: change
     */
    change: {
        oneofKind: "set";
        /**
         * The value of that entry (Optional)
         *
         * @generated from protobuf field: google.protobuf.BoolValue set = 1;
         */
        set: BoolValue;
    } | {
        oneofKind: "keep";
        /**
         * Keep the existing value
         *
         * @generated from protobuf field: massa.model.v1.Empty keep = 2;
         */
        keep: Empty;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Set or Keep AsyncMessageTrigger
 *
 * @generated from protobuf message massa.model.v1.SetOrKeepAsyncMessageTrigger
 */
export interface SetOrKeepAsyncMessageTrigger {
    /**
     * @generated from protobuf oneof: change
     */
    change: {
        oneofKind: "set";
        /**
         * The value of that entry (Optional)
         *
         * @generated from protobuf field: massa.model.v1.AsyncMessageTrigger set = 1;
         */
        set: AsyncMessageTrigger;
    } | {
        oneofKind: "keep";
        /**
         * Keep the existing value
         *
         * @generated from protobuf field: massa.model.v1.Empty keep = 2;
         */
        keep: Empty;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Structure defining a trigger for an asynchronous message
 *
 * @generated from protobuf message massa.model.v1.AsyncMessageTrigger
 */
export interface AsyncMessageTrigger {
    /**
     * Filter on the address
     *
     * @generated from protobuf field: string address = 1;
     */
    address: string;
    /**
     * Filter on the datastore key (Optional)
     *
     * @generated from protobuf field: google.protobuf.BytesValue datastore_key = 2;
     */
    datastoreKey?: BytesValue;
}
/**
 * LedgerChangeEntry
 *
 * @generated from protobuf message massa.model.v1.LedgerChangeEntry
 */
export interface LedgerChangeEntry {
    /**
     * Address
     *
     * @generated from protobuf field: string address = 1;
     */
    address: string;
    /**
     * Ledger message
     *
     * @generated from protobuf field: massa.model.v1.LedgerChangeValue value = 2;
     */
    value?: LedgerChangeValue;
}
/**
 * LedgerChangeValue
 *
 * @generated from protobuf message massa.model.v1.LedgerChangeValue
 */
export interface LedgerChangeValue {
    /**
     * The type of the change
     *
     * @generated from protobuf field: massa.model.v1.LedgerChangeType type = 1;
     */
    type: LedgerChangeType;
    /**
     * @generated from protobuf oneof: entry
     */
    entry: {
        oneofKind: "createdEntry";
        /**
         * Created ledger entry
         *
         * @generated from protobuf field: massa.model.v1.LedgerEntry created_entry = 2;
         */
        createdEntry: LedgerEntry;
    } | {
        oneofKind: "updatedEntry";
        /**
         * Update ledger entry
         *
         * @generated from protobuf field: massa.model.v1.LedgerEntryUpdate updated_entry = 3;
         */
        updatedEntry: LedgerEntryUpdate;
    } | {
        oneofKind: undefined;
    };
}
/**
 * An entry associated to an address in the `FinalLedger`
 *
 * @generated from protobuf message massa.model.v1.LedgerEntry
 */
export interface LedgerEntry {
    /**
     * The balance of that entry
     *
     * @generated from protobuf field: massa.model.v1.NativeAmount balance = 1;
     */
    balance?: NativeAmount;
    /**
     * Executable bytecode
     *
     * @generated from protobuf field: bytes bytecode = 2;
     */
    bytecode: Uint8Array;
    /**
     * A key-value store associating a hash to arbitrary bytes
     *
     * @generated from protobuf field: repeated massa.model.v1.BytesMapFieldEntry datastore = 3;
     */
    datastore: BytesMapFieldEntry[];
}
/**
 * Represents an update to one or more fields of a `LedgerEntry`
 *
 * @generated from protobuf message massa.model.v1.LedgerEntryUpdate
 */
export interface LedgerEntryUpdate {
    /**
     * Change the balance
     *
     * @generated from protobuf field: massa.model.v1.SetOrKeepBalance balance = 1;
     */
    balance?: SetOrKeepBalance;
    /**
     * Change the executable bytecode
     *
     * @generated from protobuf field: massa.model.v1.SetOrKeepBytes bytecode = 2;
     */
    bytecode?: SetOrKeepBytes;
    /**
     * Change datastore entries
     *
     * @generated from protobuf field: repeated massa.model.v1.SetOrDeleteDatastoreEntry datastore = 3;
     */
    datastore: SetOrDeleteDatastoreEntry[];
}
/**
 * Set or Keep Balance
 *
 * @generated from protobuf message massa.model.v1.SetOrKeepBalance
 */
export interface SetOrKeepBalance {
    /**
     * @generated from protobuf oneof: change
     */
    change: {
        oneofKind: "set";
        /**
         * The value of that entry (Optional)
         *
         * @generated from protobuf field: massa.model.v1.NativeAmount set = 1;
         */
        set: NativeAmount;
    } | {
        oneofKind: "keep";
        /**
         * Keep the existing value
         *
         * @generated from protobuf field: massa.model.v1.Empty keep = 2;
         */
        keep: Empty;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Set or Delete DatastoreEntry
 *
 * @generated from protobuf message massa.model.v1.SetOrDeleteDatastoreEntry
 */
export interface SetOrDeleteDatastoreEntry {
    /**
     * @generated from protobuf oneof: change
     */
    change: {
        oneofKind: "set";
        /**
         * Executable bytecode (Optional)
         *
         * @generated from protobuf field: massa.model.v1.BytesMapFieldEntry set = 1;
         */
        set: BytesMapFieldEntry;
    } | {
        oneofKind: "delete";
        /**
         * Delete the existing bytecode
         *
         * @generated from protobuf field: massa.model.v1.Empty delete = 2;
         */
        delete: Empty;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Read-only execution call
 *
 * @generated from protobuf message massa.model.v1.ReadOnlyExecutionCall
 */
export interface ReadOnlyExecutionCall {
    /**
     * Maximum gas to spend in the execution.
     *
     * @generated from protobuf field: uint64 max_gas = 1;
     */
    maxGas: bigint;
    /**
     * Call stack to simulate, older caller first
     *
     * @generated from protobuf field: repeated massa.model.v1.ExecutionStackElement call_stack = 2;
     */
    callStack: ExecutionStackElement[];
    /**
     * @generated from protobuf oneof: target
     */
    target: {
        oneofKind: "bytecodeCall";
        /**
         * Byte code
         *
         * @generated from protobuf field: massa.model.v1.BytecodeExecution bytecode_call = 3;
         */
        bytecodeCall: BytecodeExecution;
    } | {
        oneofKind: "functionCall";
        /**
         * Function call
         *
         * @generated from protobuf field: massa.model.v1.FunctionCall function_call = 4;
         */
        functionCall: FunctionCall;
    } | {
        oneofKind: undefined;
    };
    /**
     * Caller's address, (Optional) if not set, an auto-generated address will be used
     *
     * @generated from protobuf field: google.protobuf.StringValue caller_address = 5;
     */
    callerAddress?: StringValue;
    /**
     * execution start state
     *
     * Whether to start execution from final or active state
     *
     * @generated from protobuf field: bool is_final = 6;
     */
    isFinal: boolean;
}
/**
 * / Execute a bytecode
 *
 * @generated from protobuf message massa.model.v1.BytecodeExecution
 */
export interface BytecodeExecution {
    /**
     * Byte code
     *
     * @generated from protobuf field: bytes bytecode = 1;
     */
    bytecode: Uint8Array;
    /**
     * Serialized datastore (key value store)  for `ExecuteSC` Operation (Optional)
     *
     * @generated from protobuf field: bytes operation_datastore = 2;
     */
    operationDatastore: Uint8Array;
}
/**
 * Execute a function call
 *
 * @generated from protobuf message massa.model.v1.FunctionCall
 */
export interface FunctionCall {
    /**
     * Target address
     *
     * @generated from protobuf field: string target_address = 1;
     */
    targetAddress: string;
    /**
     * Target function
     *
     * @generated from protobuf field: string target_function = 2;
     */
    targetFunction: string;
    /**
     * Parameter to pass to the target function
     *
     * @generated from protobuf field: bytes parameter = 3;
     */
    parameter: Uint8Array;
}
/**
 * Structure describing the output of a read only execution
 *
 * @generated from protobuf message massa.model.v1.ReadOnlyExecutionOutput
 */
export interface ReadOnlyExecutionOutput {
    /**
     * Output of a single execution
     *
     * @generated from protobuf field: massa.model.v1.ExecutionOutput out = 1;
     */
    out?: ExecutionOutput;
    /**
     * Gas cost for this execution
     *
     * @generated from protobuf field: uint64 used_gas = 2;
     */
    usedGas: bigint;
    /**
     * Returned value from the module call
     *
     * @generated from protobuf field: bytes call_result = 3;
     */
    callResult: Uint8Array;
}
/**
 * Structure describing an element of the execution stack.
 * Every time a function is called from bytecode,
 * a new `ExecutionStackElement` is pushed at the top of the execution stack
 * to represent the local execution context of the called function,
 * instead of the caller's which should lie just below in the stack.
 *
 * @generated from protobuf message massa.model.v1.ExecutionStackElement
 */
export interface ExecutionStackElement {
    /**
     * Called address
     *
     * @generated from protobuf field: string address = 1;
     */
    address: string;
    /**
     * Coins transferred to the target address during the call
     *
     * @generated from protobuf field: massa.model.v1.NativeAmount coins = 2;
     */
    coins?: NativeAmount;
    /**
     * List of addresses owned by the current call, and on which the current call has write access.
     * This list should contain `ExecutionStackElement::address` in the sense that an address should have write access to itself.
     * This list should also contain all addresses created previously during the call
     * to allow write access on newly created addresses in order to set them up,
     * but only within the scope of the current stack element.
     * That way, only the current scope and neither its caller not the functions it calls gain this write access,
     * which is important for security.
     * Note that we use a vector instead of a pre-hashed set to ensure order determinism,
     * the performance hit of linear search remains minimal because `owned_addresses` will always contain very few elements.
     *
     * @generated from protobuf field: repeated string owned_addresses = 3;
     */
    ownedAddresses: string[];
    /**
     * Datastore (key value store) for `ExecuteSC` Operation (Optional)
     *
     * @generated from protobuf field: repeated massa.model.v1.BytesMapFieldEntry operation_datastore = 4;
     */
    operationDatastore: BytesMapFieldEntry[];
}
/**
 * ScExecutionEventStatus type enum
 *
 * @generated from protobuf enum massa.model.v1.ScExecutionEventStatus
 */
export enum ScExecutionEventStatus {
    /**
     * Default enum value
     *
     * @generated from protobuf enum value: SC_EXECUTION_EVENT_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Final status
     *
     * @generated from protobuf enum value: SC_EXECUTION_EVENT_STATUS_FINAL = 1;
     */
    FINAL = 1,
    /**
     * Read only status
     *
     * @generated from protobuf enum value: SC_EXECUTION_EVENT_STATUS_READ_ONLY = 2;
     */
    READ_ONLY = 2,
    /**
     * Candidate status
     *
     * @generated from protobuf enum value: SC_EXECUTION_EVENT_STATUS_CANDIDATE = 3;
     */
    CANDIDATE = 3
}
/**
 * ExecutionOutputStatus type enum
 *
 * @generated from protobuf enum massa.model.v1.ExecutionOutputStatus
 */
export enum ExecutionOutputStatus {
    /**
     * Default enum value
     *
     * @generated from protobuf enum value: EXECUTION_OUTPUT_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Candidate status
     *
     * @generated from protobuf enum value: EXECUTION_OUTPUT_STATUS_CANDIDATE = 1;
     */
    CANDIDATE = 1,
    /**
     * Final status
     *
     * @generated from protobuf enum value: EXECUTION_OUTPUT_STATUS_FINAL = 2;
     */
    FINAL = 2,
    /**
     * Unknown status
     *
     * @generated from protobuf enum value: EXECUTION_OUTPUT_STATUS_UNKNOWN = 3;
     */
    UNKNOWN = 3
}
/**
 * OperationExecutionStatus type enum
 *
 * @generated from protobuf enum massa.model.v1.OperationExecutionStatus
 */
export enum OperationExecutionStatus {
    /**
     * Default enum value
     *
     * @generated from protobuf enum value: OPERATION_EXECUTION_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Success status
     *
     * @generated from protobuf enum value: OPERATION_EXECUTION_STATUS_SUCCESS = 1;
     */
    SUCCESS = 1,
    /**
     * Failed only status
     *
     * @generated from protobuf enum value: OPERATION_EXECUTION_STATUS_FAILED = 2;
     */
    FAILED = 2
}
/**
 * AsyncPoolChangeType type enum
 *
 * @generated from protobuf enum massa.model.v1.AsyncPoolChangeType
 */
export enum AsyncPoolChangeType {
    /**
     * Default enum value
     *
     * @generated from protobuf enum value: ASYNC_POOL_CHANGE_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Set type
     *
     * @generated from protobuf enum value: ASYNC_POOL_CHANGE_TYPE_SET = 1;
     */
    SET = 1,
    /**
     * Activate only type
     *
     * @generated from protobuf enum value: ASYNC_POOL_CHANGE_TYPE_UPDATE = 2;
     */
    UPDATE = 2,
    /**
     * Delete only type
     *
     * @generated from protobuf enum value: ASYNC_POOL_CHANGE_TYPE_DELETE = 3;
     */
    DELETE = 3
}
/**
 * LedgerChangeType type enum
 *
 * @generated from protobuf enum massa.model.v1.LedgerChangeType
 */
export enum LedgerChangeType {
    /**
     * Default enum value
     *
     * @generated from protobuf enum value: LEDGER_CHANGE_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Set type
     *
     * @generated from protobuf enum value: LEDGER_CHANGE_TYPE_SET = 1;
     */
    SET = 1,
    /**
     * Update type
     *
     * @generated from protobuf enum value: LEDGER_CHANGE_TYPE_UPDATE = 2;
     */
    UPDATE = 2,
    /**
     * Delete type
     *
     * @generated from protobuf enum value: LEDGER_CHANGE_TYPE_DELETE = 3;
     */
    DELETE = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class SlotExecutionOutput$Type extends MessageType<SlotExecutionOutput> {
    constructor() {
        super("massa.model.v1.SlotExecutionOutput", [
            { no: 1, name: "status", kind: "enum", T: () => ["massa.model.v1.ExecutionOutputStatus", ExecutionOutputStatus, "EXECUTION_OUTPUT_STATUS_"] },
            { no: 2, name: "execution_output", kind: "message", T: () => ExecutionOutput }
        ]);
    }
    create(value?: PartialMessage<SlotExecutionOutput>): SlotExecutionOutput {
        const message = { status: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SlotExecutionOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SlotExecutionOutput): SlotExecutionOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* massa.model.v1.ExecutionOutputStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* massa.model.v1.ExecutionOutput execution_output */ 2:
                    message.executionOutput = ExecutionOutput.internalBinaryRead(reader, reader.uint32(), options, message.executionOutput);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SlotExecutionOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* massa.model.v1.ExecutionOutputStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* massa.model.v1.ExecutionOutput execution_output = 2; */
        if (message.executionOutput)
            ExecutionOutput.internalBinaryWrite(message.executionOutput, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.SlotExecutionOutput
 */
export const SlotExecutionOutput = new SlotExecutionOutput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FinalizedExecutionOutput$Type extends MessageType<FinalizedExecutionOutput> {
    constructor() {
        super("massa.model.v1.FinalizedExecutionOutput", [
            { no: 1, name: "slot", kind: "message", T: () => Slot }
        ]);
    }
    create(value?: PartialMessage<FinalizedExecutionOutput>): FinalizedExecutionOutput {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FinalizedExecutionOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FinalizedExecutionOutput): FinalizedExecutionOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* massa.model.v1.Slot slot */ 1:
                    message.slot = Slot.internalBinaryRead(reader, reader.uint32(), options, message.slot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FinalizedExecutionOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* massa.model.v1.Slot slot = 1; */
        if (message.slot)
            Slot.internalBinaryWrite(message.slot, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.FinalizedExecutionOutput
 */
export const FinalizedExecutionOutput = new FinalizedExecutionOutput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecutionOutput$Type extends MessageType<ExecutionOutput> {
    constructor() {
        super("massa.model.v1.ExecutionOutput", [
            { no: 1, name: "slot", kind: "message", T: () => Slot },
            { no: 2, name: "block_id", kind: "message", T: () => StringValue },
            { no: 3, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ScExecutionEvent },
            { no: 4, name: "state_changes", kind: "message", T: () => StateChanges }
        ]);
    }
    create(value?: PartialMessage<ExecutionOutput>): ExecutionOutput {
        const message = { events: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExecutionOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecutionOutput): ExecutionOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* massa.model.v1.Slot slot */ 1:
                    message.slot = Slot.internalBinaryRead(reader, reader.uint32(), options, message.slot);
                    break;
                case /* google.protobuf.StringValue block_id */ 2:
                    message.blockId = StringValue.internalBinaryRead(reader, reader.uint32(), options, message.blockId);
                    break;
                case /* repeated massa.model.v1.ScExecutionEvent events */ 3:
                    message.events.push(ScExecutionEvent.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* massa.model.v1.StateChanges state_changes */ 4:
                    message.stateChanges = StateChanges.internalBinaryRead(reader, reader.uint32(), options, message.stateChanges);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecutionOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* massa.model.v1.Slot slot = 1; */
        if (message.slot)
            Slot.internalBinaryWrite(message.slot, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.StringValue block_id = 2; */
        if (message.blockId)
            StringValue.internalBinaryWrite(message.blockId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated massa.model.v1.ScExecutionEvent events = 3; */
        for (let i = 0; i < message.events.length; i++)
            ScExecutionEvent.internalBinaryWrite(message.events[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.StateChanges state_changes = 4; */
        if (message.stateChanges)
            StateChanges.internalBinaryWrite(message.stateChanges, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.ExecutionOutput
 */
export const ExecutionOutput = new ExecutionOutput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScExecutionEvent$Type extends MessageType<ScExecutionEvent> {
    constructor() {
        super("massa.model.v1.ScExecutionEvent", [
            { no: 1, name: "context", kind: "message", T: () => ScExecutionEventContext },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ScExecutionEvent>): ScExecutionEvent {
        const message = { data: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ScExecutionEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScExecutionEvent): ScExecutionEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* massa.model.v1.ScExecutionEventContext context */ 1:
                    message.context = ScExecutionEventContext.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScExecutionEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* massa.model.v1.ScExecutionEventContext context = 1; */
        if (message.context)
            ScExecutionEventContext.internalBinaryWrite(message.context, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.ScExecutionEvent
 */
export const ScExecutionEvent = new ScExecutionEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScExecutionEventContext$Type extends MessageType<ScExecutionEventContext> {
    constructor() {
        super("massa.model.v1.ScExecutionEventContext", [
            { no: 1, name: "origin_slot", kind: "message", T: () => Slot },
            { no: 2, name: "block_id", kind: "message", T: () => StringValue },
            { no: 3, name: "index_in_slot", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "call_stack", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "origin_operation_id", kind: "message", T: () => StringValue },
            { no: 6, name: "is_failure", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "status", kind: "enum", T: () => ["massa.model.v1.ScExecutionEventStatus", ScExecutionEventStatus, "SC_EXECUTION_EVENT_STATUS_"] }
        ]);
    }
    create(value?: PartialMessage<ScExecutionEventContext>): ScExecutionEventContext {
        const message = { indexInSlot: 0n, callStack: [], isFailure: false, status: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ScExecutionEventContext>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScExecutionEventContext): ScExecutionEventContext {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* massa.model.v1.Slot origin_slot */ 1:
                    message.originSlot = Slot.internalBinaryRead(reader, reader.uint32(), options, message.originSlot);
                    break;
                case /* google.protobuf.StringValue block_id */ 2:
                    message.blockId = StringValue.internalBinaryRead(reader, reader.uint32(), options, message.blockId);
                    break;
                case /* uint64 index_in_slot */ 3:
                    message.indexInSlot = reader.uint64().toBigInt();
                    break;
                case /* repeated string call_stack */ 4:
                    message.callStack.push(reader.string());
                    break;
                case /* google.protobuf.StringValue origin_operation_id */ 5:
                    message.originOperationId = StringValue.internalBinaryRead(reader, reader.uint32(), options, message.originOperationId);
                    break;
                case /* bool is_failure */ 6:
                    message.isFailure = reader.bool();
                    break;
                case /* massa.model.v1.ScExecutionEventStatus status */ 7:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScExecutionEventContext, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* massa.model.v1.Slot origin_slot = 1; */
        if (message.originSlot)
            Slot.internalBinaryWrite(message.originSlot, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.StringValue block_id = 2; */
        if (message.blockId)
            StringValue.internalBinaryWrite(message.blockId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint64 index_in_slot = 3; */
        if (message.indexInSlot !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.indexInSlot);
        /* repeated string call_stack = 4; */
        for (let i = 0; i < message.callStack.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.callStack[i]);
        /* google.protobuf.StringValue origin_operation_id = 5; */
        if (message.originOperationId)
            StringValue.internalBinaryWrite(message.originOperationId, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool is_failure = 6; */
        if (message.isFailure !== false)
            writer.tag(6, WireType.Varint).bool(message.isFailure);
        /* massa.model.v1.ScExecutionEventStatus status = 7; */
        if (message.status !== 0)
            writer.tag(7, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.ScExecutionEventContext
 */
export const ScExecutionEventContext = new ScExecutionEventContext$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScExecutionEventsStatus$Type extends MessageType<ScExecutionEventsStatus> {
    constructor() {
        super("massa.model.v1.ScExecutionEventsStatus", [
            { no: 1, name: "status", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["massa.model.v1.ScExecutionEventStatus", ScExecutionEventStatus, "SC_EXECUTION_EVENT_STATUS_"] }
        ]);
    }
    create(value?: PartialMessage<ScExecutionEventsStatus>): ScExecutionEventsStatus {
        const message = { status: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ScExecutionEventsStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScExecutionEventsStatus): ScExecutionEventsStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated massa.model.v1.ScExecutionEventStatus status */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.status.push(reader.int32());
                    else
                        message.status.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScExecutionEventsStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated massa.model.v1.ScExecutionEventStatus status = 1; */
        if (message.status.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.status.length; i++)
                writer.int32(message.status[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.ScExecutionEventsStatus
 */
export const ScExecutionEventsStatus = new ScExecutionEventsStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StateChanges$Type extends MessageType<StateChanges> {
    constructor() {
        super("massa.model.v1.StateChanges", [
            { no: 1, name: "ledger_changes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => LedgerChangeEntry },
            { no: 2, name: "async_pool_changes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AsyncPoolChangeEntry },
            { no: 4, name: "executed_ops_changes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ExecutedOpsChangeEntry },
            { no: 5, name: "executed_denunciations_changes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DenunciationIndex },
            { no: 6, name: "execution_trail_hash_change", kind: "message", T: () => SetOrKeepString }
        ]);
    }
    create(value?: PartialMessage<StateChanges>): StateChanges {
        const message = { ledgerChanges: [], asyncPoolChanges: [], executedOpsChanges: [], executedDenunciationsChanges: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StateChanges>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StateChanges): StateChanges {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated massa.model.v1.LedgerChangeEntry ledger_changes */ 1:
                    message.ledgerChanges.push(LedgerChangeEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated massa.model.v1.AsyncPoolChangeEntry async_pool_changes */ 2:
                    message.asyncPoolChanges.push(AsyncPoolChangeEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated massa.model.v1.ExecutedOpsChangeEntry executed_ops_changes */ 4:
                    message.executedOpsChanges.push(ExecutedOpsChangeEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated massa.model.v1.DenunciationIndex executed_denunciations_changes */ 5:
                    message.executedDenunciationsChanges.push(DenunciationIndex.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* massa.model.v1.SetOrKeepString execution_trail_hash_change */ 6:
                    message.executionTrailHashChange = SetOrKeepString.internalBinaryRead(reader, reader.uint32(), options, message.executionTrailHashChange);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StateChanges, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated massa.model.v1.LedgerChangeEntry ledger_changes = 1; */
        for (let i = 0; i < message.ledgerChanges.length; i++)
            LedgerChangeEntry.internalBinaryWrite(message.ledgerChanges[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated massa.model.v1.AsyncPoolChangeEntry async_pool_changes = 2; */
        for (let i = 0; i < message.asyncPoolChanges.length; i++)
            AsyncPoolChangeEntry.internalBinaryWrite(message.asyncPoolChanges[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated massa.model.v1.ExecutedOpsChangeEntry executed_ops_changes = 4; */
        for (let i = 0; i < message.executedOpsChanges.length; i++)
            ExecutedOpsChangeEntry.internalBinaryWrite(message.executedOpsChanges[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated massa.model.v1.DenunciationIndex executed_denunciations_changes = 5; */
        for (let i = 0; i < message.executedDenunciationsChanges.length; i++)
            DenunciationIndex.internalBinaryWrite(message.executedDenunciationsChanges[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.SetOrKeepString execution_trail_hash_change = 6; */
        if (message.executionTrailHashChange)
            SetOrKeepString.internalBinaryWrite(message.executionTrailHashChange, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.StateChanges
 */
export const StateChanges = new StateChanges$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecutedOpsChangeEntry$Type extends MessageType<ExecutedOpsChangeEntry> {
    constructor() {
        super("massa.model.v1.ExecutedOpsChangeEntry", [
            { no: 1, name: "operation_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => ExecutedOpsChangeValue }
        ]);
    }
    create(value?: PartialMessage<ExecutedOpsChangeEntry>): ExecutedOpsChangeEntry {
        const message = { operationId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExecutedOpsChangeEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecutedOpsChangeEntry): ExecutedOpsChangeEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string operation_id */ 1:
                    message.operationId = reader.string();
                    break;
                case /* massa.model.v1.ExecutedOpsChangeValue value */ 2:
                    message.value = ExecutedOpsChangeValue.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecutedOpsChangeEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string operation_id = 1; */
        if (message.operationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.operationId);
        /* massa.model.v1.ExecutedOpsChangeValue value = 2; */
        if (message.value)
            ExecutedOpsChangeValue.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.ExecutedOpsChangeEntry
 */
export const ExecutedOpsChangeEntry = new ExecutedOpsChangeEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecutedOpsChangeValue$Type extends MessageType<ExecutedOpsChangeValue> {
    constructor() {
        super("massa.model.v1.ExecutedOpsChangeValue", [
            { no: 1, name: "status", kind: "enum", T: () => ["massa.model.v1.OperationExecutionStatus", OperationExecutionStatus, "OPERATION_EXECUTION_STATUS_"] },
            { no: 2, name: "slot", kind: "message", T: () => Slot }
        ]);
    }
    create(value?: PartialMessage<ExecutedOpsChangeValue>): ExecutedOpsChangeValue {
        const message = { status: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExecutedOpsChangeValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecutedOpsChangeValue): ExecutedOpsChangeValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* massa.model.v1.OperationExecutionStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* massa.model.v1.Slot slot */ 2:
                    message.slot = Slot.internalBinaryRead(reader, reader.uint32(), options, message.slot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecutedOpsChangeValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* massa.model.v1.OperationExecutionStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* massa.model.v1.Slot slot = 2; */
        if (message.slot)
            Slot.internalBinaryWrite(message.slot, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.ExecutedOpsChangeValue
 */
export const ExecutedOpsChangeValue = new ExecutedOpsChangeValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AsyncPoolChangeEntry$Type extends MessageType<AsyncPoolChangeEntry> {
    constructor() {
        super("massa.model.v1.AsyncPoolChangeEntry", [
            { no: 1, name: "async_message_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => AsyncPoolChangeValue }
        ]);
    }
    create(value?: PartialMessage<AsyncPoolChangeEntry>): AsyncPoolChangeEntry {
        const message = { asyncMessageId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AsyncPoolChangeEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AsyncPoolChangeEntry): AsyncPoolChangeEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string async_message_id */ 1:
                    message.asyncMessageId = reader.string();
                    break;
                case /* massa.model.v1.AsyncPoolChangeValue value */ 2:
                    message.value = AsyncPoolChangeValue.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AsyncPoolChangeEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string async_message_id = 1; */
        if (message.asyncMessageId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.asyncMessageId);
        /* massa.model.v1.AsyncPoolChangeValue value = 2; */
        if (message.value)
            AsyncPoolChangeValue.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.AsyncPoolChangeEntry
 */
export const AsyncPoolChangeEntry = new AsyncPoolChangeEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AsyncPoolChangeValue$Type extends MessageType<AsyncPoolChangeValue> {
    constructor() {
        super("massa.model.v1.AsyncPoolChangeValue", [
            { no: 1, name: "type", kind: "enum", T: () => ["massa.model.v1.AsyncPoolChangeType", AsyncPoolChangeType, "ASYNC_POOL_CHANGE_TYPE_"] },
            { no: 2, name: "created_message", kind: "message", oneof: "message", T: () => AsyncMessage },
            { no: 3, name: "updated_message", kind: "message", oneof: "message", T: () => AsyncMessageUpdate }
        ]);
    }
    create(value?: PartialMessage<AsyncPoolChangeValue>): AsyncPoolChangeValue {
        const message = { type: 0, message: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AsyncPoolChangeValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AsyncPoolChangeValue): AsyncPoolChangeValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* massa.model.v1.AsyncPoolChangeType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* massa.model.v1.AsyncMessage created_message */ 2:
                    message.message = {
                        oneofKind: "createdMessage",
                        createdMessage: AsyncMessage.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).createdMessage)
                    };
                    break;
                case /* massa.model.v1.AsyncMessageUpdate updated_message */ 3:
                    message.message = {
                        oneofKind: "updatedMessage",
                        updatedMessage: AsyncMessageUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.message as any).updatedMessage)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AsyncPoolChangeValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* massa.model.v1.AsyncPoolChangeType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* massa.model.v1.AsyncMessage created_message = 2; */
        if (message.message.oneofKind === "createdMessage")
            AsyncMessage.internalBinaryWrite(message.message.createdMessage, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.AsyncMessageUpdate updated_message = 3; */
        if (message.message.oneofKind === "updatedMessage")
            AsyncMessageUpdate.internalBinaryWrite(message.message.updatedMessage, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.AsyncPoolChangeValue
 */
export const AsyncPoolChangeValue = new AsyncPoolChangeValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AsyncMessage$Type extends MessageType<AsyncMessage> {
    constructor() {
        super("massa.model.v1.AsyncMessage", [
            { no: 1, name: "emission_slot", kind: "message", T: () => Slot },
            { no: 2, name: "emission_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "destination", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "handler", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "max_gas", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "fee", kind: "message", T: () => NativeAmount },
            { no: 8, name: "coins", kind: "message", T: () => NativeAmount },
            { no: 9, name: "validity_start", kind: "message", T: () => Slot },
            { no: 10, name: "validity_end", kind: "message", T: () => Slot },
            { no: 11, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 12, name: "trigger", kind: "message", T: () => AsyncMessageTrigger },
            { no: 13, name: "can_be_executed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AsyncMessage>): AsyncMessage {
        const message = { emissionIndex: 0n, sender: "", destination: "", handler: "", maxGas: 0n, data: new Uint8Array(0), canBeExecuted: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AsyncMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AsyncMessage): AsyncMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* massa.model.v1.Slot emission_slot */ 1:
                    message.emissionSlot = Slot.internalBinaryRead(reader, reader.uint32(), options, message.emissionSlot);
                    break;
                case /* uint64 emission_index */ 2:
                    message.emissionIndex = reader.uint64().toBigInt();
                    break;
                case /* string sender */ 3:
                    message.sender = reader.string();
                    break;
                case /* string destination */ 4:
                    message.destination = reader.string();
                    break;
                case /* string handler */ 5:
                    message.handler = reader.string();
                    break;
                case /* uint64 max_gas */ 6:
                    message.maxGas = reader.uint64().toBigInt();
                    break;
                case /* massa.model.v1.NativeAmount fee */ 7:
                    message.fee = NativeAmount.internalBinaryRead(reader, reader.uint32(), options, message.fee);
                    break;
                case /* massa.model.v1.NativeAmount coins */ 8:
                    message.coins = NativeAmount.internalBinaryRead(reader, reader.uint32(), options, message.coins);
                    break;
                case /* massa.model.v1.Slot validity_start */ 9:
                    message.validityStart = Slot.internalBinaryRead(reader, reader.uint32(), options, message.validityStart);
                    break;
                case /* massa.model.v1.Slot validity_end */ 10:
                    message.validityEnd = Slot.internalBinaryRead(reader, reader.uint32(), options, message.validityEnd);
                    break;
                case /* bytes data */ 11:
                    message.data = reader.bytes();
                    break;
                case /* massa.model.v1.AsyncMessageTrigger trigger */ 12:
                    message.trigger = AsyncMessageTrigger.internalBinaryRead(reader, reader.uint32(), options, message.trigger);
                    break;
                case /* bool can_be_executed */ 13:
                    message.canBeExecuted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AsyncMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* massa.model.v1.Slot emission_slot = 1; */
        if (message.emissionSlot)
            Slot.internalBinaryWrite(message.emissionSlot, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 emission_index = 2; */
        if (message.emissionIndex !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.emissionIndex);
        /* string sender = 3; */
        if (message.sender !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.sender);
        /* string destination = 4; */
        if (message.destination !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.destination);
        /* string handler = 5; */
        if (message.handler !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.handler);
        /* uint64 max_gas = 6; */
        if (message.maxGas !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.maxGas);
        /* massa.model.v1.NativeAmount fee = 7; */
        if (message.fee)
            NativeAmount.internalBinaryWrite(message.fee, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.NativeAmount coins = 8; */
        if (message.coins)
            NativeAmount.internalBinaryWrite(message.coins, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.Slot validity_start = 9; */
        if (message.validityStart)
            Slot.internalBinaryWrite(message.validityStart, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.Slot validity_end = 10; */
        if (message.validityEnd)
            Slot.internalBinaryWrite(message.validityEnd, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* bytes data = 11; */
        if (message.data.length)
            writer.tag(11, WireType.LengthDelimited).bytes(message.data);
        /* massa.model.v1.AsyncMessageTrigger trigger = 12; */
        if (message.trigger)
            AsyncMessageTrigger.internalBinaryWrite(message.trigger, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* bool can_be_executed = 13; */
        if (message.canBeExecuted !== false)
            writer.tag(13, WireType.Varint).bool(message.canBeExecuted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.AsyncMessage
 */
export const AsyncMessage = new AsyncMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AsyncMessageUpdate$Type extends MessageType<AsyncMessageUpdate> {
    constructor() {
        super("massa.model.v1.AsyncMessageUpdate", [
            { no: 1, name: "emission_slot", kind: "message", T: () => SetOrKeepSlot },
            { no: 2, name: "emission_index", kind: "message", T: () => SetOrKeepUint64 },
            { no: 3, name: "sender", kind: "message", T: () => SetOrKeepString },
            { no: 4, name: "destination", kind: "message", T: () => SetOrKeepString },
            { no: 5, name: "handler", kind: "message", T: () => SetOrKeepString },
            { no: 6, name: "max_gas", kind: "message", T: () => SetOrKeepUint64 },
            { no: 7, name: "fee", kind: "message", T: () => SetOrKeepUint64 },
            { no: 8, name: "coins", kind: "message", T: () => SetOrKeepUint64 },
            { no: 9, name: "validity_start", kind: "message", T: () => SetOrKeepSlot },
            { no: 10, name: "validity_end", kind: "message", T: () => SetOrKeepSlot },
            { no: 11, name: "data", kind: "message", T: () => SetOrKeepBytes },
            { no: 12, name: "trigger", kind: "message", T: () => SetOrKeepAsyncMessageTrigger },
            { no: 13, name: "can_be_executed", kind: "message", T: () => SetOrKeepBool }
        ]);
    }
    create(value?: PartialMessage<AsyncMessageUpdate>): AsyncMessageUpdate {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AsyncMessageUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AsyncMessageUpdate): AsyncMessageUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* massa.model.v1.SetOrKeepSlot emission_slot */ 1:
                    message.emissionSlot = SetOrKeepSlot.internalBinaryRead(reader, reader.uint32(), options, message.emissionSlot);
                    break;
                case /* massa.model.v1.SetOrKeepUint64 emission_index */ 2:
                    message.emissionIndex = SetOrKeepUint64.internalBinaryRead(reader, reader.uint32(), options, message.emissionIndex);
                    break;
                case /* massa.model.v1.SetOrKeepString sender */ 3:
                    message.sender = SetOrKeepString.internalBinaryRead(reader, reader.uint32(), options, message.sender);
                    break;
                case /* massa.model.v1.SetOrKeepString destination */ 4:
                    message.destination = SetOrKeepString.internalBinaryRead(reader, reader.uint32(), options, message.destination);
                    break;
                case /* massa.model.v1.SetOrKeepString handler */ 5:
                    message.handler = SetOrKeepString.internalBinaryRead(reader, reader.uint32(), options, message.handler);
                    break;
                case /* massa.model.v1.SetOrKeepUint64 max_gas */ 6:
                    message.maxGas = SetOrKeepUint64.internalBinaryRead(reader, reader.uint32(), options, message.maxGas);
                    break;
                case /* massa.model.v1.SetOrKeepUint64 fee */ 7:
                    message.fee = SetOrKeepUint64.internalBinaryRead(reader, reader.uint32(), options, message.fee);
                    break;
                case /* massa.model.v1.SetOrKeepUint64 coins */ 8:
                    message.coins = SetOrKeepUint64.internalBinaryRead(reader, reader.uint32(), options, message.coins);
                    break;
                case /* massa.model.v1.SetOrKeepSlot validity_start */ 9:
                    message.validityStart = SetOrKeepSlot.internalBinaryRead(reader, reader.uint32(), options, message.validityStart);
                    break;
                case /* massa.model.v1.SetOrKeepSlot validity_end */ 10:
                    message.validityEnd = SetOrKeepSlot.internalBinaryRead(reader, reader.uint32(), options, message.validityEnd);
                    break;
                case /* massa.model.v1.SetOrKeepBytes data */ 11:
                    message.data = SetOrKeepBytes.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                case /* massa.model.v1.SetOrKeepAsyncMessageTrigger trigger */ 12:
                    message.trigger = SetOrKeepAsyncMessageTrigger.internalBinaryRead(reader, reader.uint32(), options, message.trigger);
                    break;
                case /* massa.model.v1.SetOrKeepBool can_be_executed */ 13:
                    message.canBeExecuted = SetOrKeepBool.internalBinaryRead(reader, reader.uint32(), options, message.canBeExecuted);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AsyncMessageUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* massa.model.v1.SetOrKeepSlot emission_slot = 1; */
        if (message.emissionSlot)
            SetOrKeepSlot.internalBinaryWrite(message.emissionSlot, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.SetOrKeepUint64 emission_index = 2; */
        if (message.emissionIndex)
            SetOrKeepUint64.internalBinaryWrite(message.emissionIndex, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.SetOrKeepString sender = 3; */
        if (message.sender)
            SetOrKeepString.internalBinaryWrite(message.sender, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.SetOrKeepString destination = 4; */
        if (message.destination)
            SetOrKeepString.internalBinaryWrite(message.destination, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.SetOrKeepString handler = 5; */
        if (message.handler)
            SetOrKeepString.internalBinaryWrite(message.handler, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.SetOrKeepUint64 max_gas = 6; */
        if (message.maxGas)
            SetOrKeepUint64.internalBinaryWrite(message.maxGas, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.SetOrKeepUint64 fee = 7; */
        if (message.fee)
            SetOrKeepUint64.internalBinaryWrite(message.fee, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.SetOrKeepUint64 coins = 8; */
        if (message.coins)
            SetOrKeepUint64.internalBinaryWrite(message.coins, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.SetOrKeepSlot validity_start = 9; */
        if (message.validityStart)
            SetOrKeepSlot.internalBinaryWrite(message.validityStart, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.SetOrKeepSlot validity_end = 10; */
        if (message.validityEnd)
            SetOrKeepSlot.internalBinaryWrite(message.validityEnd, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.SetOrKeepBytes data = 11; */
        if (message.data)
            SetOrKeepBytes.internalBinaryWrite(message.data, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.SetOrKeepAsyncMessageTrigger trigger = 12; */
        if (message.trigger)
            SetOrKeepAsyncMessageTrigger.internalBinaryWrite(message.trigger, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.SetOrKeepBool can_be_executed = 13; */
        if (message.canBeExecuted)
            SetOrKeepBool.internalBinaryWrite(message.canBeExecuted, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.AsyncMessageUpdate
 */
export const AsyncMessageUpdate = new AsyncMessageUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetOrKeepSlot$Type extends MessageType<SetOrKeepSlot> {
    constructor() {
        super("massa.model.v1.SetOrKeepSlot", [
            { no: 1, name: "set", kind: "message", oneof: "change", T: () => Slot },
            { no: 2, name: "keep", kind: "message", oneof: "change", T: () => Empty }
        ]);
    }
    create(value?: PartialMessage<SetOrKeepSlot>): SetOrKeepSlot {
        const message = { change: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetOrKeepSlot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetOrKeepSlot): SetOrKeepSlot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* massa.model.v1.Slot set */ 1:
                    message.change = {
                        oneofKind: "set",
                        set: Slot.internalBinaryRead(reader, reader.uint32(), options, (message.change as any).set)
                    };
                    break;
                case /* massa.model.v1.Empty keep */ 2:
                    message.change = {
                        oneofKind: "keep",
                        keep: Empty.internalBinaryRead(reader, reader.uint32(), options, (message.change as any).keep)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetOrKeepSlot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* massa.model.v1.Slot set = 1; */
        if (message.change.oneofKind === "set")
            Slot.internalBinaryWrite(message.change.set, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.Empty keep = 2; */
        if (message.change.oneofKind === "keep")
            Empty.internalBinaryWrite(message.change.keep, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.SetOrKeepSlot
 */
export const SetOrKeepSlot = new SetOrKeepSlot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetOrKeepUint64$Type extends MessageType<SetOrKeepUint64> {
    constructor() {
        super("massa.model.v1.SetOrKeepUint64", [
            { no: 1, name: "set", kind: "message", oneof: "change", T: () => UInt64Value },
            { no: 2, name: "keep", kind: "message", oneof: "change", T: () => Empty }
        ]);
    }
    create(value?: PartialMessage<SetOrKeepUint64>): SetOrKeepUint64 {
        const message = { change: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetOrKeepUint64>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetOrKeepUint64): SetOrKeepUint64 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.UInt64Value set */ 1:
                    message.change = {
                        oneofKind: "set",
                        set: UInt64Value.internalBinaryRead(reader, reader.uint32(), options, (message.change as any).set)
                    };
                    break;
                case /* massa.model.v1.Empty keep */ 2:
                    message.change = {
                        oneofKind: "keep",
                        keep: Empty.internalBinaryRead(reader, reader.uint32(), options, (message.change as any).keep)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetOrKeepUint64, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.UInt64Value set = 1; */
        if (message.change.oneofKind === "set")
            UInt64Value.internalBinaryWrite(message.change.set, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.Empty keep = 2; */
        if (message.change.oneofKind === "keep")
            Empty.internalBinaryWrite(message.change.keep, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.SetOrKeepUint64
 */
export const SetOrKeepUint64 = new SetOrKeepUint64$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetOrKeepString$Type extends MessageType<SetOrKeepString> {
    constructor() {
        super("massa.model.v1.SetOrKeepString", [
            { no: 1, name: "set", kind: "message", oneof: "change", T: () => StringValue },
            { no: 2, name: "keep", kind: "message", oneof: "change", T: () => Empty }
        ]);
    }
    create(value?: PartialMessage<SetOrKeepString>): SetOrKeepString {
        const message = { change: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetOrKeepString>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetOrKeepString): SetOrKeepString {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.StringValue set */ 1:
                    message.change = {
                        oneofKind: "set",
                        set: StringValue.internalBinaryRead(reader, reader.uint32(), options, (message.change as any).set)
                    };
                    break;
                case /* massa.model.v1.Empty keep */ 2:
                    message.change = {
                        oneofKind: "keep",
                        keep: Empty.internalBinaryRead(reader, reader.uint32(), options, (message.change as any).keep)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetOrKeepString, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.StringValue set = 1; */
        if (message.change.oneofKind === "set")
            StringValue.internalBinaryWrite(message.change.set, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.Empty keep = 2; */
        if (message.change.oneofKind === "keep")
            Empty.internalBinaryWrite(message.change.keep, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.SetOrKeepString
 */
export const SetOrKeepString = new SetOrKeepString$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetOrKeepBytes$Type extends MessageType<SetOrKeepBytes> {
    constructor() {
        super("massa.model.v1.SetOrKeepBytes", [
            { no: 1, name: "set", kind: "message", oneof: "change", T: () => BytesValue },
            { no: 2, name: "keep", kind: "message", oneof: "change", T: () => Empty }
        ]);
    }
    create(value?: PartialMessage<SetOrKeepBytes>): SetOrKeepBytes {
        const message = { change: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetOrKeepBytes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetOrKeepBytes): SetOrKeepBytes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.BytesValue set */ 1:
                    message.change = {
                        oneofKind: "set",
                        set: BytesValue.internalBinaryRead(reader, reader.uint32(), options, (message.change as any).set)
                    };
                    break;
                case /* massa.model.v1.Empty keep */ 2:
                    message.change = {
                        oneofKind: "keep",
                        keep: Empty.internalBinaryRead(reader, reader.uint32(), options, (message.change as any).keep)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetOrKeepBytes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.BytesValue set = 1; */
        if (message.change.oneofKind === "set")
            BytesValue.internalBinaryWrite(message.change.set, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.Empty keep = 2; */
        if (message.change.oneofKind === "keep")
            Empty.internalBinaryWrite(message.change.keep, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.SetOrKeepBytes
 */
export const SetOrKeepBytes = new SetOrKeepBytes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetOrKeepBool$Type extends MessageType<SetOrKeepBool> {
    constructor() {
        super("massa.model.v1.SetOrKeepBool", [
            { no: 1, name: "set", kind: "message", oneof: "change", T: () => BoolValue },
            { no: 2, name: "keep", kind: "message", oneof: "change", T: () => Empty }
        ]);
    }
    create(value?: PartialMessage<SetOrKeepBool>): SetOrKeepBool {
        const message = { change: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetOrKeepBool>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetOrKeepBool): SetOrKeepBool {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.BoolValue set */ 1:
                    message.change = {
                        oneofKind: "set",
                        set: BoolValue.internalBinaryRead(reader, reader.uint32(), options, (message.change as any).set)
                    };
                    break;
                case /* massa.model.v1.Empty keep */ 2:
                    message.change = {
                        oneofKind: "keep",
                        keep: Empty.internalBinaryRead(reader, reader.uint32(), options, (message.change as any).keep)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetOrKeepBool, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.BoolValue set = 1; */
        if (message.change.oneofKind === "set")
            BoolValue.internalBinaryWrite(message.change.set, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.Empty keep = 2; */
        if (message.change.oneofKind === "keep")
            Empty.internalBinaryWrite(message.change.keep, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.SetOrKeepBool
 */
export const SetOrKeepBool = new SetOrKeepBool$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetOrKeepAsyncMessageTrigger$Type extends MessageType<SetOrKeepAsyncMessageTrigger> {
    constructor() {
        super("massa.model.v1.SetOrKeepAsyncMessageTrigger", [
            { no: 1, name: "set", kind: "message", oneof: "change", T: () => AsyncMessageTrigger },
            { no: 2, name: "keep", kind: "message", oneof: "change", T: () => Empty }
        ]);
    }
    create(value?: PartialMessage<SetOrKeepAsyncMessageTrigger>): SetOrKeepAsyncMessageTrigger {
        const message = { change: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetOrKeepAsyncMessageTrigger>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetOrKeepAsyncMessageTrigger): SetOrKeepAsyncMessageTrigger {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* massa.model.v1.AsyncMessageTrigger set */ 1:
                    message.change = {
                        oneofKind: "set",
                        set: AsyncMessageTrigger.internalBinaryRead(reader, reader.uint32(), options, (message.change as any).set)
                    };
                    break;
                case /* massa.model.v1.Empty keep */ 2:
                    message.change = {
                        oneofKind: "keep",
                        keep: Empty.internalBinaryRead(reader, reader.uint32(), options, (message.change as any).keep)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetOrKeepAsyncMessageTrigger, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* massa.model.v1.AsyncMessageTrigger set = 1; */
        if (message.change.oneofKind === "set")
            AsyncMessageTrigger.internalBinaryWrite(message.change.set, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.Empty keep = 2; */
        if (message.change.oneofKind === "keep")
            Empty.internalBinaryWrite(message.change.keep, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.SetOrKeepAsyncMessageTrigger
 */
export const SetOrKeepAsyncMessageTrigger = new SetOrKeepAsyncMessageTrigger$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AsyncMessageTrigger$Type extends MessageType<AsyncMessageTrigger> {
    constructor() {
        super("massa.model.v1.AsyncMessageTrigger", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "datastore_key", kind: "message", T: () => BytesValue }
        ]);
    }
    create(value?: PartialMessage<AsyncMessageTrigger>): AsyncMessageTrigger {
        const message = { address: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AsyncMessageTrigger>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AsyncMessageTrigger): AsyncMessageTrigger {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* google.protobuf.BytesValue datastore_key */ 2:
                    message.datastoreKey = BytesValue.internalBinaryRead(reader, reader.uint32(), options, message.datastoreKey);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AsyncMessageTrigger, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* google.protobuf.BytesValue datastore_key = 2; */
        if (message.datastoreKey)
            BytesValue.internalBinaryWrite(message.datastoreKey, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.AsyncMessageTrigger
 */
export const AsyncMessageTrigger = new AsyncMessageTrigger$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LedgerChangeEntry$Type extends MessageType<LedgerChangeEntry> {
    constructor() {
        super("massa.model.v1.LedgerChangeEntry", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => LedgerChangeValue }
        ]);
    }
    create(value?: PartialMessage<LedgerChangeEntry>): LedgerChangeEntry {
        const message = { address: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LedgerChangeEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LedgerChangeEntry): LedgerChangeEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* massa.model.v1.LedgerChangeValue value */ 2:
                    message.value = LedgerChangeValue.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LedgerChangeEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* massa.model.v1.LedgerChangeValue value = 2; */
        if (message.value)
            LedgerChangeValue.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.LedgerChangeEntry
 */
export const LedgerChangeEntry = new LedgerChangeEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LedgerChangeValue$Type extends MessageType<LedgerChangeValue> {
    constructor() {
        super("massa.model.v1.LedgerChangeValue", [
            { no: 1, name: "type", kind: "enum", T: () => ["massa.model.v1.LedgerChangeType", LedgerChangeType, "LEDGER_CHANGE_TYPE_"] },
            { no: 2, name: "created_entry", kind: "message", oneof: "entry", T: () => LedgerEntry },
            { no: 3, name: "updated_entry", kind: "message", oneof: "entry", T: () => LedgerEntryUpdate }
        ]);
    }
    create(value?: PartialMessage<LedgerChangeValue>): LedgerChangeValue {
        const message = { type: 0, entry: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LedgerChangeValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LedgerChangeValue): LedgerChangeValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* massa.model.v1.LedgerChangeType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* massa.model.v1.LedgerEntry created_entry */ 2:
                    message.entry = {
                        oneofKind: "createdEntry",
                        createdEntry: LedgerEntry.internalBinaryRead(reader, reader.uint32(), options, (message.entry as any).createdEntry)
                    };
                    break;
                case /* massa.model.v1.LedgerEntryUpdate updated_entry */ 3:
                    message.entry = {
                        oneofKind: "updatedEntry",
                        updatedEntry: LedgerEntryUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.entry as any).updatedEntry)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LedgerChangeValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* massa.model.v1.LedgerChangeType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* massa.model.v1.LedgerEntry created_entry = 2; */
        if (message.entry.oneofKind === "createdEntry")
            LedgerEntry.internalBinaryWrite(message.entry.createdEntry, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.LedgerEntryUpdate updated_entry = 3; */
        if (message.entry.oneofKind === "updatedEntry")
            LedgerEntryUpdate.internalBinaryWrite(message.entry.updatedEntry, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.LedgerChangeValue
 */
export const LedgerChangeValue = new LedgerChangeValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LedgerEntry$Type extends MessageType<LedgerEntry> {
    constructor() {
        super("massa.model.v1.LedgerEntry", [
            { no: 1, name: "balance", kind: "message", T: () => NativeAmount },
            { no: 2, name: "bytecode", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "datastore", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BytesMapFieldEntry }
        ]);
    }
    create(value?: PartialMessage<LedgerEntry>): LedgerEntry {
        const message = { bytecode: new Uint8Array(0), datastore: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LedgerEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LedgerEntry): LedgerEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* massa.model.v1.NativeAmount balance */ 1:
                    message.balance = NativeAmount.internalBinaryRead(reader, reader.uint32(), options, message.balance);
                    break;
                case /* bytes bytecode */ 2:
                    message.bytecode = reader.bytes();
                    break;
                case /* repeated massa.model.v1.BytesMapFieldEntry datastore */ 3:
                    message.datastore.push(BytesMapFieldEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LedgerEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* massa.model.v1.NativeAmount balance = 1; */
        if (message.balance)
            NativeAmount.internalBinaryWrite(message.balance, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes bytecode = 2; */
        if (message.bytecode.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.bytecode);
        /* repeated massa.model.v1.BytesMapFieldEntry datastore = 3; */
        for (let i = 0; i < message.datastore.length; i++)
            BytesMapFieldEntry.internalBinaryWrite(message.datastore[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.LedgerEntry
 */
export const LedgerEntry = new LedgerEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LedgerEntryUpdate$Type extends MessageType<LedgerEntryUpdate> {
    constructor() {
        super("massa.model.v1.LedgerEntryUpdate", [
            { no: 1, name: "balance", kind: "message", T: () => SetOrKeepBalance },
            { no: 2, name: "bytecode", kind: "message", T: () => SetOrKeepBytes },
            { no: 3, name: "datastore", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SetOrDeleteDatastoreEntry }
        ]);
    }
    create(value?: PartialMessage<LedgerEntryUpdate>): LedgerEntryUpdate {
        const message = { datastore: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LedgerEntryUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LedgerEntryUpdate): LedgerEntryUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* massa.model.v1.SetOrKeepBalance balance */ 1:
                    message.balance = SetOrKeepBalance.internalBinaryRead(reader, reader.uint32(), options, message.balance);
                    break;
                case /* massa.model.v1.SetOrKeepBytes bytecode */ 2:
                    message.bytecode = SetOrKeepBytes.internalBinaryRead(reader, reader.uint32(), options, message.bytecode);
                    break;
                case /* repeated massa.model.v1.SetOrDeleteDatastoreEntry datastore */ 3:
                    message.datastore.push(SetOrDeleteDatastoreEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LedgerEntryUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* massa.model.v1.SetOrKeepBalance balance = 1; */
        if (message.balance)
            SetOrKeepBalance.internalBinaryWrite(message.balance, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.SetOrKeepBytes bytecode = 2; */
        if (message.bytecode)
            SetOrKeepBytes.internalBinaryWrite(message.bytecode, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated massa.model.v1.SetOrDeleteDatastoreEntry datastore = 3; */
        for (let i = 0; i < message.datastore.length; i++)
            SetOrDeleteDatastoreEntry.internalBinaryWrite(message.datastore[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.LedgerEntryUpdate
 */
export const LedgerEntryUpdate = new LedgerEntryUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetOrKeepBalance$Type extends MessageType<SetOrKeepBalance> {
    constructor() {
        super("massa.model.v1.SetOrKeepBalance", [
            { no: 1, name: "set", kind: "message", oneof: "change", T: () => NativeAmount },
            { no: 2, name: "keep", kind: "message", oneof: "change", T: () => Empty }
        ]);
    }
    create(value?: PartialMessage<SetOrKeepBalance>): SetOrKeepBalance {
        const message = { change: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetOrKeepBalance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetOrKeepBalance): SetOrKeepBalance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* massa.model.v1.NativeAmount set */ 1:
                    message.change = {
                        oneofKind: "set",
                        set: NativeAmount.internalBinaryRead(reader, reader.uint32(), options, (message.change as any).set)
                    };
                    break;
                case /* massa.model.v1.Empty keep */ 2:
                    message.change = {
                        oneofKind: "keep",
                        keep: Empty.internalBinaryRead(reader, reader.uint32(), options, (message.change as any).keep)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetOrKeepBalance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* massa.model.v1.NativeAmount set = 1; */
        if (message.change.oneofKind === "set")
            NativeAmount.internalBinaryWrite(message.change.set, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.Empty keep = 2; */
        if (message.change.oneofKind === "keep")
            Empty.internalBinaryWrite(message.change.keep, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.SetOrKeepBalance
 */
export const SetOrKeepBalance = new SetOrKeepBalance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetOrDeleteDatastoreEntry$Type extends MessageType<SetOrDeleteDatastoreEntry> {
    constructor() {
        super("massa.model.v1.SetOrDeleteDatastoreEntry", [
            { no: 1, name: "set", kind: "message", oneof: "change", T: () => BytesMapFieldEntry },
            { no: 2, name: "delete", kind: "message", oneof: "change", T: () => Empty }
        ]);
    }
    create(value?: PartialMessage<SetOrDeleteDatastoreEntry>): SetOrDeleteDatastoreEntry {
        const message = { change: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetOrDeleteDatastoreEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetOrDeleteDatastoreEntry): SetOrDeleteDatastoreEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* massa.model.v1.BytesMapFieldEntry set */ 1:
                    message.change = {
                        oneofKind: "set",
                        set: BytesMapFieldEntry.internalBinaryRead(reader, reader.uint32(), options, (message.change as any).set)
                    };
                    break;
                case /* massa.model.v1.Empty delete */ 2:
                    message.change = {
                        oneofKind: "delete",
                        delete: Empty.internalBinaryRead(reader, reader.uint32(), options, (message.change as any).delete)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetOrDeleteDatastoreEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* massa.model.v1.BytesMapFieldEntry set = 1; */
        if (message.change.oneofKind === "set")
            BytesMapFieldEntry.internalBinaryWrite(message.change.set, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.Empty delete = 2; */
        if (message.change.oneofKind === "delete")
            Empty.internalBinaryWrite(message.change.delete, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.SetOrDeleteDatastoreEntry
 */
export const SetOrDeleteDatastoreEntry = new SetOrDeleteDatastoreEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadOnlyExecutionCall$Type extends MessageType<ReadOnlyExecutionCall> {
    constructor() {
        super("massa.model.v1.ReadOnlyExecutionCall", [
            { no: 1, name: "max_gas", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "call_stack", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ExecutionStackElement },
            { no: 3, name: "bytecode_call", kind: "message", oneof: "target", T: () => BytecodeExecution },
            { no: 4, name: "function_call", kind: "message", oneof: "target", T: () => FunctionCall },
            { no: 5, name: "caller_address", kind: "message", T: () => StringValue },
            { no: 6, name: "is_final", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ReadOnlyExecutionCall>): ReadOnlyExecutionCall {
        const message = { maxGas: 0n, callStack: [], target: { oneofKind: undefined }, isFinal: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadOnlyExecutionCall>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadOnlyExecutionCall): ReadOnlyExecutionCall {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 max_gas */ 1:
                    message.maxGas = reader.uint64().toBigInt();
                    break;
                case /* repeated massa.model.v1.ExecutionStackElement call_stack */ 2:
                    message.callStack.push(ExecutionStackElement.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* massa.model.v1.BytecodeExecution bytecode_call */ 3:
                    message.target = {
                        oneofKind: "bytecodeCall",
                        bytecodeCall: BytecodeExecution.internalBinaryRead(reader, reader.uint32(), options, (message.target as any).bytecodeCall)
                    };
                    break;
                case /* massa.model.v1.FunctionCall function_call */ 4:
                    message.target = {
                        oneofKind: "functionCall",
                        functionCall: FunctionCall.internalBinaryRead(reader, reader.uint32(), options, (message.target as any).functionCall)
                    };
                    break;
                case /* google.protobuf.StringValue caller_address */ 5:
                    message.callerAddress = StringValue.internalBinaryRead(reader, reader.uint32(), options, message.callerAddress);
                    break;
                case /* bool is_final */ 6:
                    message.isFinal = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadOnlyExecutionCall, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 max_gas = 1; */
        if (message.maxGas !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.maxGas);
        /* repeated massa.model.v1.ExecutionStackElement call_stack = 2; */
        for (let i = 0; i < message.callStack.length; i++)
            ExecutionStackElement.internalBinaryWrite(message.callStack[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.BytecodeExecution bytecode_call = 3; */
        if (message.target.oneofKind === "bytecodeCall")
            BytecodeExecution.internalBinaryWrite(message.target.bytecodeCall, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* massa.model.v1.FunctionCall function_call = 4; */
        if (message.target.oneofKind === "functionCall")
            FunctionCall.internalBinaryWrite(message.target.functionCall, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.StringValue caller_address = 5; */
        if (message.callerAddress)
            StringValue.internalBinaryWrite(message.callerAddress, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool is_final = 6; */
        if (message.isFinal !== false)
            writer.tag(6, WireType.Varint).bool(message.isFinal);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.ReadOnlyExecutionCall
 */
export const ReadOnlyExecutionCall = new ReadOnlyExecutionCall$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BytecodeExecution$Type extends MessageType<BytecodeExecution> {
    constructor() {
        super("massa.model.v1.BytecodeExecution", [
            { no: 1, name: "bytecode", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "operation_datastore", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<BytecodeExecution>): BytecodeExecution {
        const message = { bytecode: new Uint8Array(0), operationDatastore: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BytecodeExecution>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BytecodeExecution): BytecodeExecution {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes bytecode */ 1:
                    message.bytecode = reader.bytes();
                    break;
                case /* bytes operation_datastore */ 2:
                    message.operationDatastore = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BytecodeExecution, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes bytecode = 1; */
        if (message.bytecode.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.bytecode);
        /* bytes operation_datastore = 2; */
        if (message.operationDatastore.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.operationDatastore);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.BytecodeExecution
 */
export const BytecodeExecution = new BytecodeExecution$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FunctionCall$Type extends MessageType<FunctionCall> {
    constructor() {
        super("massa.model.v1.FunctionCall", [
            { no: 1, name: "target_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target_function", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "parameter", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<FunctionCall>): FunctionCall {
        const message = { targetAddress: "", targetFunction: "", parameter: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FunctionCall>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FunctionCall): FunctionCall {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string target_address */ 1:
                    message.targetAddress = reader.string();
                    break;
                case /* string target_function */ 2:
                    message.targetFunction = reader.string();
                    break;
                case /* bytes parameter */ 3:
                    message.parameter = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FunctionCall, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string target_address = 1; */
        if (message.targetAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.targetAddress);
        /* string target_function = 2; */
        if (message.targetFunction !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.targetFunction);
        /* bytes parameter = 3; */
        if (message.parameter.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.parameter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.FunctionCall
 */
export const FunctionCall = new FunctionCall$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadOnlyExecutionOutput$Type extends MessageType<ReadOnlyExecutionOutput> {
    constructor() {
        super("massa.model.v1.ReadOnlyExecutionOutput", [
            { no: 1, name: "out", kind: "message", T: () => ExecutionOutput },
            { no: 2, name: "used_gas", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "call_result", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ReadOnlyExecutionOutput>): ReadOnlyExecutionOutput {
        const message = { usedGas: 0n, callResult: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadOnlyExecutionOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadOnlyExecutionOutput): ReadOnlyExecutionOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* massa.model.v1.ExecutionOutput out */ 1:
                    message.out = ExecutionOutput.internalBinaryRead(reader, reader.uint32(), options, message.out);
                    break;
                case /* uint64 used_gas */ 2:
                    message.usedGas = reader.uint64().toBigInt();
                    break;
                case /* bytes call_result */ 3:
                    message.callResult = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadOnlyExecutionOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* massa.model.v1.ExecutionOutput out = 1; */
        if (message.out)
            ExecutionOutput.internalBinaryWrite(message.out, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 used_gas = 2; */
        if (message.usedGas !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.usedGas);
        /* bytes call_result = 3; */
        if (message.callResult.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.callResult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.ReadOnlyExecutionOutput
 */
export const ReadOnlyExecutionOutput = new ReadOnlyExecutionOutput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecutionStackElement$Type extends MessageType<ExecutionStackElement> {
    constructor() {
        super("massa.model.v1.ExecutionStackElement", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "coins", kind: "message", T: () => NativeAmount },
            { no: 3, name: "owned_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "operation_datastore", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BytesMapFieldEntry }
        ]);
    }
    create(value?: PartialMessage<ExecutionStackElement>): ExecutionStackElement {
        const message = { address: "", ownedAddresses: [], operationDatastore: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExecutionStackElement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecutionStackElement): ExecutionStackElement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* massa.model.v1.NativeAmount coins */ 2:
                    message.coins = NativeAmount.internalBinaryRead(reader, reader.uint32(), options, message.coins);
                    break;
                case /* repeated string owned_addresses */ 3:
                    message.ownedAddresses.push(reader.string());
                    break;
                case /* repeated massa.model.v1.BytesMapFieldEntry operation_datastore */ 4:
                    message.operationDatastore.push(BytesMapFieldEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecutionStackElement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* massa.model.v1.NativeAmount coins = 2; */
        if (message.coins)
            NativeAmount.internalBinaryWrite(message.coins, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated string owned_addresses = 3; */
        for (let i = 0; i < message.ownedAddresses.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.ownedAddresses[i]);
        /* repeated massa.model.v1.BytesMapFieldEntry operation_datastore = 4; */
        for (let i = 0; i < message.operationDatastore.length; i++)
            BytesMapFieldEntry.internalBinaryWrite(message.operationDatastore[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message massa.model.v1.ExecutionStackElement
 */
export const ExecutionStackElement = new ExecutionStackElement$Type();
